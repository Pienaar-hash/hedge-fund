# Quant & Infra Audit — 2025-10-26

## Snapshot
- `logs/nav_log.json` last NAV sample is `t=1760725654.13` (8.9 days old) while executor timestamps in `logs/execution/risk_vetoes.jsonl` sit around `1761497xxx`, so no fresh equity feed has reached the stack since at least Oct 17.
- `logs/cache/nav_confirmed.json` is 3.9 days old (`ts=1761159741.46`) with `sources_ok=false` because both `balances_ok` and `positions_ok` are flagged false, so the risk gate only ever sees stale NAV snapshots.
- Risk vetos are dominated by `nav_stale` (3,852 entries vs. 691 `max_trade_nav` in `logs/execution/risk_vetoes.jsonl`), proving order flow is effectively shut off by the stale NAV guard.
- `logs/cache/peak_state.json` only contains `{"day":"2025-10-19","peak":1000.0}` and no NAV/drawdown fields, so daily-loss and drawdown caps operate on empty data.
- `logs/execution/sync_heartbeats.jsonl` shows **only** `executor_live` records (lagging by ~300 s) and zero `sync_daemon` entries, confirming the Firestore replicator is not running.

## Risk-Control Findings
1. **Fail-closed NAV gate is starving fills.** `check_order` pulls NAV freshness from `get_nav_freshness_snapshot` and vetoes trades when `nav_age > nav_freshness_seconds` (see `execution/risk_limits.py#L631-L727`), but the snapshot never refreshes (`logs/cache/nav_confirmed.json` is 3.9 days old). As a result, every order over the past ~4 days hit `nav_stale` and no hedge can deploy even though capital and signals remain live.
2. **Daily loss / drawdown caps are effectively no-ops.** The config advertises global drawdown settings (`config/risk_limits.json:1-35`), yet `execution/risk_limits.py` never reads `max_nav_drawdown_pct` and `_drawdown_snapshot` depends on `logs/cache/peak_state.json`, which lacks current `nav`, `dd_pct`, or `realized_pnl` fields. Because `peak_state` has not been updated since Oct 19, daily-loss checks line 545 onward in `execution/risk_limits.py` always compare against zero and silently pass.
3. **Risk telemetry cannot surface trending breaches.** `_emit_veto` writes each veto through `execution/log_utils.log_event`, which rewrites whole JSONL files per call; under the current nav-stale storm (3,852 entries) that code path blocks the executor loop and still provides no aggregation/alerting. There is no structured metric for “nav stale minutes” that supervisors can monitor.

## NAV Freshness Findings
1. **No job is updating `nav_log.json`.** `write_nav` (`execution/nav.py#L184-L232`) only runs when called, yet no long-running service invokes it, so the NAV history feeding Streamlit and drawdown math froze 8.9 days ago.
2. **Confirmed NAV snapshot only advances when both balances *and* positions succeed.** `_futures_nav_usdt` (`execution/nav.py#L27-L75`) refuses to persist the wallet NAV whenever the positions API errors, even if balances are healthy. Given Binance intermittently times out `/fapi/v2/positionRisk`, this design flips `sources_ok` to false, never refreshes `ts`, and bricks the risk gate.
3. **Treasury/reserve valuation quietly drops assets.** `_treasury_nav_usdt` and `_reserves_nav_usd` (`execution/nav.py#L82-L147`) fan out synchronous price requests for each asset; when a price call fails it simply omits the holding, understating NAV with no stale flag propagated back to risk or dashboards.

## Firestore Sync Findings
1. **`sync_daemon` cannot start.** It imports `sync_leaderboard/sync_nav/sync_positions` from `execution.sync_state` (`execution/sync_daemon.py:10-125`), but those functions no longer exist—only `_commit_*` helpers and `sync_once` remain in `execution/sync_state.py`. The module therefore crashes on import, explaining the missing `sync_daemon` heartbeats and the 8.9-day-old NAV cache.
2. **`execution/hedge_sync.py` overwrites production docs with placeholders.** The loop (lines 8‑27) writes empty NAV series and empty position lists to Firestore every 60 seconds with whatever `ENV` is set (default `dev`), nuking real telemetry whenever someone runs the script locally.
3. **State publisher bypasses shared Firestore client and defaults to prod.** `execution/state_publish.py` hard-codes `FS_ROOT = "hedge/{ENV}/state"` with `ENV=os.getenv("ENV","prod")` and opens a fresh `google.cloud.firestore.Client` every call (`execution/state_publish.py:226-344`). There is no retry/backoff, no respect for `FIRESTORE_ENABLED=0`, and no way to publish to a staging namespace without exporting `ENV` beforehand, so local testing risks polluting prod while production runs silently degrade when ADC/creds vanish.
4. **No heartbeat or health doc tracks Firestore sync quality.** With `sync_daemon` offline and `_publish_health` never called, supervisors only see executor heartbeats; Firestore outages, queue backlogs, or placeholder writers (hedge_sync) leave no audit trail.

## Codex Patch Prompts
1. **Repair the NAV pipeline.** Ensure `_futures_nav_usdt` persists the last good wallet NAV even when one upstream call fails, add explicit stale flags, and introduce a daemon (or executor hook) that periodically calls `write_nav` so `logs/nav_log.json` stays fresh. Cover scheduler + failure cases with pytest fixtures targeting `execution/nav.py` and `execution/risk_limits.py`.
2. **Rebuild drawdown + daily-loss enforcement.** Teach `execution/drawdown_tracker.py` to persist `nav`, `dd_pct`, and `realized_pnl_today`, wire `execution/risk_limits.py` to consume `max_nav_drawdown_pct`, and add alarms when `peak_state` is older than one reset period. Include regression tests that simulate stale peak files.
3. **Fix Firestore synchronization.** Reintroduce `sync_nav/sync_positions/sync_leaderboard` wrappers in `execution/sync_state.py`, update `execution/sync_daemon.py` to use them (and to fail fast when caches are stale), and emit heartbeat entries to `logs/execution/sync_heartbeats.jsonl` plus `publish_heartbeat`. Remove or guard `execution/hedge_sync.py` so it cannot clobber prod data, and refactor `execution/state_publish.py` to reuse `utils.firestore_client.get_db()` with env scoping + retries.
4. **Add observability and alerts.** Extend `logs/execution/risk_vetoes.jsonl` reporting (or a metrics sink) to count nav-stale minutes and Firestore failures, and surface those metrics through `/hedge/{env}/telemetry/health` so dashboards and PagerDuty can alarm before trading halts for days.
