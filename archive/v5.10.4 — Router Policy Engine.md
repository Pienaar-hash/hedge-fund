üéØ v5.10.4 ‚Äî Router Policy Engine

Goal: Add a small, deterministic policy layer that tells the router:

whether to run maker-first or go straight taker

when to treat router as degraded and avoid maker noise

what taker bias to use (‚Äúprefer_maker‚Äù, ‚Äúbalanced‚Äù, ‚Äúprefer_taker‚Äù)

All based on:

router_effectiveness_7d(symbol)

fallback ratio, maker fill ratio, slippage median

ATR regime / volatility

(optionally) hourly expectancy

This is on/off / bias logic, not another big refactor.

üü¶ Commit 1 ‚Äî Add router policy engine

Commit message:

[v5.10.4] Add router policy engine based on router effectiveness and volatility

üìÑ execution/intel/router_policy.py (new)
from __future__ import annotations

"""
Router policy engine (v5.10.4).

This module classifies router quality and derives a simple policy for:
- maker_first enable/disable
- taker_bias ("prefer_maker", "balanced", "prefer_taker")

It is purely read-only: no side effects, no network calls.
"""

from dataclasses import dataclass
from typing import Dict, Any

from execution.utils.metrics import router_effectiveness_7d
from execution.intel.maker_offset import classify_atr_regime


@dataclass
class RouterPolicy:
    maker_first: bool
    taker_bias: str
    quality: str
    reason: str


def classify_router_quality(eff: Dict[str, Any]) -> str:
    """
    Classify router quality into: "good", "ok", "degraded", "broken".
    """
    maker = eff.get("maker_fill_ratio") or 0.0
    fallback = eff.get("fallback_ratio") or 0.0
    slip_med = eff.get("slip_q50")
    if slip_med is None:
        slip_med = 0.0

    # Very high fallback or absurd slippage ‚Üí broken
    if fallback >= 0.9 or slip_med >= 20.0:
        return "broken"

    # High fallback or consistently bad slippage ‚Üí degraded
    if fallback >= 0.6 or slip_med >= 8.0:
        return "degraded"

    # Good maker fills and manageable fallback/slippage ‚Üí good
    if maker >= 0.7 and fallback <= 0.4 and slip_med <= 4.0:
        return "good"

    return "ok"


def router_policy(symbol: str) -> RouterPolicy:
    """
    Compute a simple router policy for a symbol.

    Uses:
    - router_effectiveness_7d(symbol)
    - ATR regime via classify_atr_regime(symbol)

    Returns:
        RouterPolicy(maker_first, taker_bias, quality, reason)
    """
    eff = router_effectiveness_7d(symbol) or {}
    quality = classify_router_quality(eff)
    regime = classify_atr_regime(symbol)

    maker_first = True
    taker_bias = "balanced"
    reason_parts = [f"quality={quality}", f"regime={regime}"]

    # Baseline by quality
    if quality == "broken":
        maker_first = False
        taker_bias = "prefer_taker"
        reason_parts.append("fallback/slippage too high ‚Üí disable maker_first")
    elif quality == "degraded":
        maker_first = True
        taker_bias = "prefer_taker"
        reason_parts.append("degraded router ‚Üí more taker-friendly")
    elif quality == "good":
        maker_first = True
        taker_bias = "prefer_maker"
        reason_parts.append("good router ‚Üí favor maker_first")

    # Volatility override: panic regime = extra caution
    if regime == "panic":
        taker_bias = "prefer_taker"
        if quality in ("degraded", "broken"):
            maker_first = False
            reason_parts.append("panic regime + weak router ‚Üí disable maker_first")

    reason = "; ".join(reason_parts)
    return RouterPolicy(
        maker_first=maker_first,
        taker_bias=taker_bias,
        quality=quality,
        reason=reason,
    )

üìÑ tests/test_router_policy.py (new)
# tests/test_router_policy.py

from execution.intel.router_policy import router_policy, classify_router_quality


def test_classify_router_quality_tiers_execution_intelligence():
    good = classify_router_quality(
        {"maker_fill_ratio": 0.8, "fallback_ratio": 0.2, "slip_q50": 2.0}
    )
    degraded = classify_router_quality(
        {"maker_fill_ratio": 0.4, "fallback_ratio": 0.7, "slip_q50": 6.0}
    )
    broken = classify_router_quality(
        {"maker_fill_ratio": 0.2, "fallback_ratio": 0.95, "slip_q50": 25.0}
    )
    ok = classify_router_quality(
        {"maker_fill_ratio": 0.5, "fallback_ratio": 0.3, "slip_q50": 5.0}
    )

    assert good == "good"
    assert degraded == "degraded"
    assert broken == "broken"
    assert ok == "ok"


def test_router_policy_disables_maker_when_broken_execution_intelligence(monkeypatch):
    monkeypatch.setattr(
        "execution.intel.router_policy.router_effectiveness_7d",
        lambda s: {"maker_fill_ratio": 0.2, "fallback_ratio": 0.95, "slip_q50": 30.0},
    )
    monkeypatch.setattr(
        "execution.intel.router_policy.classify_atr_regime",
        lambda s: "normal",
    )

    policy = router_policy("BTCUSDC")
    assert policy.quality == "broken"
    assert policy.maker_first is False
    assert policy.taker_bias == "prefer_taker"


def test_router_policy_prefers_maker_when_good_execution_intelligence(monkeypatch):
    monkeypatch.setattr(
        "execution.intel.router_policy.router_effectiveness_7d",
        lambda s: {"maker_fill_ratio": 0.8, "fallback_ratio": 0.2, "slip_q50": 2.0},
    )
    monkeypatch.setattr(
        "execution.intel.router_policy.classify_atr_regime",
        lambda s: "normal",
    )

    policy = router_policy("ETHUSDC")
    assert policy.quality == "good"
    assert policy.maker_first is True
    assert policy.taker_bias == "prefer_maker"

üü© Commit 2 ‚Äî Wire router policy into order_router

Commit message:

[v5.10.4] Apply router policy in order_router to gate maker_first

üìÑ Patch: execution/order_router.py

At top:

from execution.intel.router_policy import router_policy


Inside your route_order or equivalent, where you currently decide maker_first (and/or read it from context), add:

# existing flag from context:
ctx_maker_first = bool(router_ctx.get("maker_first", True))

# NEW: policy-based adjustment
policy = router_policy(symbol)
effective_maker_first = ctx_maker_first and policy.maker_first

# optionally stash policy in ctx for logging:
router_ctx["router_policy"] = {
    "quality": policy.quality,
    "taker_bias": policy.taker_bias,
    "maker_first": policy.maker_first,
}


Then, wherever you do:

if maker_first:
    # maker-first routing path


switch to:

if effective_maker_first:
    # maker-first routing path
else:
    # skip straight to taker logic


Optionally, if you have separate paths for ‚Äúprefer_taker‚Äù vs ‚Äúprefer_maker‚Äù, adjust your internal logic with policy.taker_bias (e.g. when deciding how aggressively you fallback to taker).

üü• Commit 3 ‚Äî Surface router policy in execution health

Commit message:

[v5.10.4] Include router policy classification in execution health snapshots

üìÑ Patch: execution/utils/execution_health.py

At top:

from execution.intel.router_policy import router_policy


In compute_execution_health(symbol) where you build the router section:

eff = router_effectiveness_7d(symbol)
policy = router_policy(symbol)

router = {
    "maker_fill_ratio": eff.get("maker_fill_ratio"),
    "fallback_ratio": eff.get("fallback_ratio"),
    "slip_q25": eff.get("slip_q25"),
    "slip_q50": eff.get("slip_q50"),
    "slip_q75": eff.get("slip_q75"),
    "maker_offset_bps": maker_offset_bps,     # existing from v5.10.3
    "policy_quality": policy.quality,         # NEW
    "policy_maker_first": policy.maker_first, # NEW
    "policy_taker_bias": policy.taker_bias,   # NEW
}


Dashboard can then render those fields in the Execution Health Overview.

üü® Commit 4 ‚Äî Test router policy surfaced in health

Commit message:

[v5.10.4] Add tests for router policy fields in execution health snapshot

üìÑ Extend tests/test_execution_health.py

Add a test:

from execution.utils import execution_health as eh


def test_execution_health_includes_router_policy_execution_intelligence(monkeypatch):
    monkeypatch.setattr(
        "execution.utils.execution_health.router_effectiveness_7d",
        lambda symbol: {
            "maker_fill_ratio": 0.2,
            "fallback_ratio": 0.95,
            "slip_q50": 30.0,
        },
    )
    # use real classify_atr_regime if you want; or stub:
    monkeypatch.setattr(
        "execution.utils.execution_health.classify_atr_regime",
        lambda s: "normal",
    )
    # router_policy uses router_effectiveness_7d + classify_atr_regime;
    # but we can just monkeypatch router_policy directly if simpler:
    from execution.intel.router_policy import RouterPolicy
    monkeypatch.setattr(
        "execution.utils.execution_health.router_policy",
        lambda symbol: RouterPolicy(
            maker_first=False, taker_bias="prefer_taker", quality="broken", reason="test",
        ),
    )

    snapshot = eh.compute_execution_health("BTCUSDC")
    router = snapshot["router"]

    assert router["policy_quality"] == "broken"
    assert router["policy_maker_first"] is False
    assert router["policy_taker_bias"] == "prefer_taker"