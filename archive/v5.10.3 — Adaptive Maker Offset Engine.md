ğŸ”¥ v5.10.3 â€” Adaptive Maker Offset Engine begins now â€” this is the part where execution intelligence finally hits routing behavior, not just size.

This sprint introduces intelligent maker quoting: tightening when conditions are good, widening when router metrics or volatility suggest caution, and using slippage quartiles & fallback ratios to dynamically tune offsets.

ğŸ¯ v5.10.3 â€” Objective

Use real telemetry â€” ATR regime, slippage quartiles, fallback ratio, hourly expectancy â€” to decide:

1. How far away from mid to place maker orders (offset_bps)
2. When to tighten offsets (good router, quiet vol, positive expectancy)
3. When to widen offsets (bad router, fallback spikes, hot ATR regime, negative expectancy)
4. When to temporarily disable maker-first entirely (extreme fallback or slippage)

This is not full router auto-tuning yet â€” thatâ€™s v5.10.4.
Here we focus purely on calculating an adaptive offset.

ğŸ— v5.10.3 Architecture

We add a new module:

execution/intel/maker_offset.py


This module grabs metrics via:

router_effectiveness_7d(symbol)

atr_pct(symbol)

hourly_expectancy(symbol)

slippage quartiles

fallback ratio

ATR regime classification (quiet, normal, hot)

Then outputs a single clean function:

def suggest_maker_offset_bps(symbol: str) -> float:
    ...


This is wired into:

execution/order_router.py (maker-first routing path)

optional surfacing in execution health â†’ dashboard

And tested via a new file:

tests/test_maker_offset.py

ğŸ“¦ Commit 1 â€” Add maker_offset engine

Commit message:

[v5.10.3] Add adaptive maker offset engine using router, volatility, and expectancy telemetry

ğŸ“„ File: execution/intel/maker_offset.py (skeleton)
from __future__ import annotations

"""
Adaptive maker offset engine (v5.10.3)

This module computes a dynamic maker quote offset (in bps) using live
telemetry from router metrics, volatility, and time-of-day expectancy.

Key signals:
- slippage quartiles (Q25/Q50/Q75)
- fallback_ratio
- maker_fill_ratio
- ATR ratio (50 vs 500 bars)
- hourly expectancy (positive or negative)
"""

from typing import Optional
from execution.utils.metrics import router_effectiveness_7d
from execution.intel.expectancy_map import hourly_expectancy
from execution.utils.vol import atr_pct


def classify_atr_regime(symbol: str) -> str:
    """Return 'quiet', 'normal', 'hot', or 'panic'."""
    s50 = atr_pct(symbol, 50)
    s500 = atr_pct(symbol, 500)
    if s500 <= 0:
        return "normal"
    ratio = s50 / s500

    if ratio < 0.5:
        return "quiet"
    if ratio < 1.5:
        return "normal"
    if ratio < 2.5:
        return "hot"
    return "panic"


def suggest_maker_offset_bps(symbol: str) -> float:
    """
    Suggest a signed offset in bps relative to mid for maker orders.
    Higher => further from mid (more conservative).
    Lower => closer to mid (more aggressive).

    This is deterministic and bounded.
    """

    eff = router_effectiveness_7d(symbol) or {}
    fallback = eff.get("fallback_ratio", 0.0) or 0.0
    maker_fill = eff.get("maker_fill_ratio", 0.0) or 0.0
    slip_med = eff.get("slip_q50", 0.0) or 0.0

    regime = classify_atr_regime(symbol)

    # Default baseline
    offset = 2.0    # 2 bps baseline

    # Volatility regimes
    if regime == "quiet":
        offset -= 0.5   # tighter in quiet ranges
    elif regime == "hot":
        offset += 0.5
    elif regime == "panic":
        offset += 1.0

    # Router quality adjustments
    # Good maker effectiveness: tighten
    if maker_fill > 0.7:
        offset -= 0.5
    # High fallback: widen
    if fallback > 0.5:
        offset += 1.0
    if fallback > 0.8:
        offset += 1.5

    # Slippage adjustments
    if slip_med > 5.0:
        offset += 0.8
    elif slip_med < 1.0:
        offset -= 0.2

    # Expectancy adjustments (hour-of-day)
    hourly = hourly_expectancy(symbol)
    import datetime as dt
    current_hour = dt.datetime.utcnow().hour
    expect = hourly.get(current_hour, {}).get("exp_per_notional")

    if expect is not None:
        if expect > 0:
            offset -= 0.2
        elif expect < 0:
            offset += 0.2

    # Clamp to safe bounds
    return max(0.5, min(offset, 8.0))


Notes:

The actual numbers here are intentionally conservative.

In v5.10.4 routing policy, these will be blended with maker-first enable/disable.

ğŸ” Commit 2 â€” Integrate maker_offset into order_router

Commit message:

[v5.10.3] Integrate adaptive maker offsets into maker-first routing path

ğŸ“„ Patch: execution/order_router.py

Find where maker price is computed (usually something like):

maker_px = mid_price * (1 - offset_bps / 10000)  # for buys


Patch to:

from execution.intel.maker_offset import suggest_maker_offset_bps


Then:

offset_bps = suggest_maker_offset_bps(symbol)
maker_px = compute_price_from_offset(mid_price, offset_bps, side)


If you donâ€™t have a helper, add:

def _apply_offset(mid: float, bps: float, side: str) -> float:
    """Return price adjusted by bps away from mid."""
    if side == "BUY":
        return mid * (1 - bps / 10000)
    else:
        return mid * (1 + bps / 10000)

ğŸ“¡ Commit 3 â€” Surface maker offsets in execution health

Commit message:

[v5.10.3] Add maker offset telemetry to execution health snapshots

ğŸ“„ Patch: execution/utils/execution_health.py

Add:

from execution.intel.maker_offset import suggest_maker_offset_bps


In compute_execution_health(symbol) sizing or router section:

maker_offset = suggest_maker_offset_bps(symbol)
router_section["maker_offset_bps"] = maker_offset


Dashboard will now show â€œcurrent maker offsetâ€ per symbol.

ğŸ§ª Commit 4 â€” Unit Tests

Commit message:

[v5.10.3] Add regression tests for adaptive maker offsets

ğŸ“„ File: tests/test_maker_offset.py
from execution.intel.maker_offset import suggest_maker_offset_bps


def test_offset_tightens_when_router_good_execution_intelligence(monkeypatch):
    monkeypatch.setattr(
        "execution.intel.maker_offset.router_effectiveness_7d",
        lambda s: {"maker_fill_ratio": 0.9, "fallback_ratio": 0.1, "slip_q50": 0.5},
    )
    monkeypatch.setattr(
        "execution.intel.maker_offset.classify_atr_regime",
        lambda s: "quiet",
    )
    monkeypatch.setattr(
        "execution.intel.maker_offset.hourly_expectancy",
        lambda s: {12: {"exp_per_notional": 0.001}},  # positive expectancy
    )
    # freeze time to hour 12
    monkeypatch.setattr(
        "execution.intel.maker_offset.dt",
        __import__("datetime"),
    )

    off = suggest_maker_offset_bps("BTCUSDC")
    assert off < 2.0  # baseline 2bps but tightened


def test_offset_widens_in_hot_regime_or_high_fallback_execution_intelligence(monkeypatch):
    monkeypatch.setattr(
        "execution.intel.maker_offset.router_effectiveness_7d",
        lambda s: {"maker_fill_ratio": 0.4, "fallback_ratio": 0.7, "slip_q50": 4.0},
    )
    monkeypatch.setattr(
        "execution.intel.maker_offset.classify_atr_regime",
        lambda s: "hot",
    )
    monkeypatch.setattr(
        "execution.intel.maker_offset.hourly_expectancy",
        lambda s: {12: {"exp_per_notional": -0.002}},
    )

    import datetime
    monkeypatch.setattr(
        "execution.intel.maker_offset.dt.datetime",
        type("FakeDT", (), {"utcfromtimestamp": lambda t: datetime.datetime(2024,1,1,12,0,0), "utcnow": lambda: datetime.datetime(2024,1,1,12,0,0)}),
    )

    off = suggest_maker_offset_bps("BTCUSDC")
    assert off > 2.0  # baseline widened
