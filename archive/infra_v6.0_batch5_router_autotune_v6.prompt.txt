You are the Quant & Infra patch agent for the hedge-fund repo.

Stage
- Batches 0–4 are merged and green:
  - Docs & topology aligned.
  - Config schemas normalized (strategy_config vs risk_limits vs pairs_universe).
  - Execution & risk contracts clarified (executor + screener share caps; reason strings config-driven).
  - Telemetry v2: canonical logs/state/*.json + JSONL histories; dashboard reads state.
  - Expectancy v6 + Symbol scoring v6: pure intel, behind INTEL_V6_ENABLED, writing:
      logs/state/expectancy_v6.json
      logs/state/symbol_scores_v6.json

Goal — Batch 5: Router Auto-Tune v6
- Build a **pure-intel auto-tune engine** for router policy:
  - Classify router regimes.
  - Derive router quality.
  - Propose maker/taker bias + offset suggestions per symbol.
- Absolutely NO live router behavior changes:
  - Suggestions only.
  - Written as state docs.
  - Optional, flag-gated hooks.

======================================================================
1) Canonical Router Regime & Policy Quality
======================================================================

Create or update:

- execution/intel/router_autotune_v6.py   (NEW)
- execution/intel/router_policy.py        (ONLY extend for classification helpers, do not change core behavior)
- execution/utils/metrics.py              (if needed for derived stats)

Tasks:

1.1 Define a canonical router "regime" classification.

Using enriched router metrics and router_health.json (from Batch 3), implement helpers like:

- classify_router_regime(metrics: dict) -> str
- compute_router_summary(metrics: Iterable[dict]) -> dict

Regime examples (exact names to standardize):

- "maker_strong"      (high maker fill, low fallback, acceptable slippage)
- "balanced"
- "fallback_heavy"    (high fallback_rate)
- "slippage_hot"      (slip_p95_bps above threshold)
- "broken"            (very low fill rate or extreme latency)

Use fields already present in metrics and router_health:

- maker_fill_rate
- fallback_rate
- slip_p50_bps / slip_p95_bps
- ack_latency_ms (and/or p50)
- policy.maker_first / policy.taker_bias
- policy.quality (if it exists now)

1.2 Policy "quality" classification.

Expose a helper to standardize policy quality:

- classify_router_quality(fill_rate, slip_p95_bps, fallback_rate, latency) -> str

Expected quality labels:

- "good"
- "ok"
- "degraded"
- "broken"

This must be **consistent** with existing router_policy behavior, but you may:

- Factor out common logic from execution/intel/router_policy.py into shared helpers.
- Add more explicit thresholds and document them in code comments.

Constraints:

- Do NOT change live decisions in router_policy.
- Classification helpers should simply expose clearly testable semantics.

======================================================================
2) Router Auto-Tune Engine (Suggestions Only)
======================================================================

Create or update:

- execution/intel/router_autotune_v6.py   (NEW, main engine)
- execution/state_publish.py              (add writer for suggestions)
- logs/state/router_policy_suggestions_v6.json (output target)

Inputs:

- logs/state/expectancy_v6.json
- logs/state/symbol_scores_v6.json
- logs/state/router_health.json
- config/risk_limits.json (for global numeric bounds)
- config/pairs_universe.json (for symbol metadata, if needed)

Outputs:

- A **suggestions** state doc, e.g.:

  logs/state/router_policy_suggestions_v6.json:

  {
    "generated_ts": "...",
    "lookback_days": 7,
    "symbols": [
      {
        "symbol": "BTCUSDT",
        "current_policy": {
          "maker_first": true,
          "taker_bias": 0.2,
          "offset_bps": 2
        },
        "regime": "maker_strong",
        "quality": "good",
        "metrics": {
          "fill_rate": ...,
          "fallback_rate": ...,
          "slip_p50_bps": ...,
          "slip_p95_bps": ...,
          "latency_p50_ms": ...
        },
        "proposed_policy": {
          "maker_first": true,
          "taker_bias": 0.15,
          "offset_bps": 1
        },
        "rationale": [
          "High expectancy and strong maker quality, safe to tighten maker bias slightly.",
          "Slippage within target: no need to widen offsets."
        ]
      },
      ...
    ]
  }

Rules for proposals:

- Use a bounded range for offsets and taker_bias:
  - e.g. offset_bps ∈ [0, max_offset_bps_configured]
  - taker_bias ∈ [0.0, 1.0]
- Proposals should **nudge**, not jump:
  - e.g. Δtaker_bias in small steps (e.g. ±0.05 per cycle).
  - Δoffset_bps in small increments (e.g. ±1–2 bps).
- Base direction of suggestions on:
  - Expectancy and symbol_score:
    - higher expectancy → more willingness to favor maker.
    - poor expectancy → more conservative maker bias.
  - Router quality:
    - "maker_strong": allow more maker bias, maybe tighter over time.
    - "fallback_heavy" or "slippage_hot": reduce maker bias, widen offsets.
    - "broken": suggest disabling maker-first (taker-only policy).

No changes are executed by router_autotune_v6; it only writes suggestions.

======================================================================
3) CLI & Probe Script
======================================================================

Create:

- scripts/router_autotune_v6_probe.py

Behavior:

- CLI that:
  - Reads expectancy_v6.json, symbol_scores_v6.json, router_health.json.
  - Runs router_autotune_v6 build_suggestions() (or similar).
  - Writes logs/state/router_policy_suggestions_v6.json (via state_publish helpers).
  - Prints a compact table to stdout for ops/dev, e.g.:

    SYMBOL | REGIME          | QUALITY  | CURRENT (maker_first / bias / offset_bps) | PROPOSED (maker_first / bias / offset_bps)

Constraints:

- No execution or risk changes.
- CLI is idempotent and safe to run repeatedly, reading only from logs/ and config/.

======================================================================
4) Executor/State Integration (Flag-Gated)
======================================================================

Update:

- execution/state_publish.py
  - Add helper to write router_policy_suggestions_v6.json.

- execution/executor_live.py
  - Add an optional telemetry/intel hook that:
    - Only runs if ROUTER_AUTOTUNE_V6_ENABLED (or similar) is set.
    - Periodically (e.g. on a throttle) calls the router_autotune_v6 engine to refresh suggestions.
    - Writes suggestions via state_publish.
  - Must:
    - be non-blocking (catch and log intel errors, do not break execution),
    - not modify any in-memory RouterPolicy or router behavior.

======================================================================
5) Tests
======================================================================

Create:

- tests/test_router_autotune_v6.py

Test coverage:

- Synthetic router metrics + expectancy + symbol scores:
  - High expectancy + "maker_strong" regime → proposed maker_first stays true or bias decreases (more maker).
  - Poor expectancy + "fallback_heavy" or "slippage_hot" regimes → proposed taker_bias increases and/or offset_bps increases.
- Ensure:
  - Suggestions respect bounds (offset range, bias range).
  - Suggestions move in small, controlled steps (e.g. max Δtaker_bias per cycle).

Extend (if useful):

- tests/test_router_policy.py
  - New tests for regime/quality classification helpers.
- tests/test_router_metrics_effectiveness.py
  - Validate that derived regime & quality use the enriched metrics fields.

Validation commands:

- Minimal intel suite:

  python -m pytest \
    tests/test_expectancy_v6.py \
    tests/test_symbol_score_v6.py \
    tests/test_router_metrics_effectiveness.py \
    tests/test_router_autotune_v6.py -q

- Core regression:

  python -m pytest \
    tests/test_risk_limits.py \
    tests/test_screener_tier_caps.py \
    tests/test_exchange_dry_run.py \
    tests/test_router_smoke.py \
    tests/test_router_policy.py \
    tests/test_router_metrics_effectiveness.py \
    tests/test_order_router_ack.py \
    tests/test_order_metrics.py \
    tests/test_config_parsing.py \
    tests/test_expectancy_v6.py \
    tests/test_symbol_score_v6.py \
    tests/test_router_autotune_v6.py -q

Constraints

- Do NOT change actual routing decisions in execution/order_router.py.
- Do NOT change risk limits, position sizing, or concurrency.
- All changes are intel-only, suggestion-only, and fully optional via flags.
- The system must behave exactly as before when intel flags are disabled.
