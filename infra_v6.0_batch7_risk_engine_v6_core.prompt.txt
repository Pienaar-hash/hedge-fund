You are the Quant & Infra patch agent for the hedge-fund repo.

Stage
- Batches 0–6 are merged and green:
  - Docs/topology aligned; config schemas normalized.
  - Execution & risk contracts clarified; screener + executor share caps.
  - Telemetry v2 with logs/state/*.json snapshots.
  - Intel v6: expectancy, symbol scores, router auto-tune, feedback allocator.
- We now have *_suggestions_v6.json state docs for router policy and risk allocation.

Goal — Batch 7: Introduce RiskEngine v6 Core (no behavior change)
- Implement a clean RiskEngine v6 object + API that:
  - Wraps existing risk_limits logic.
  - Produces deterministic, structured RiskDecision outputs.
  - Is used by screener + executor in a *flag-gated* way (`RISK_ENGINE_V6_ENABLED`).
- Behavior must remain identical for orders when v6 risk is enabled:
  - same veto decisions
  - same reasons
  - same caps
- This is a refactor / layering step only; **no new risk rules**.

======================================================================
1) New RiskEngine Module
======================================================================

Create:

- execution/risk_engine_v6.py

Key concepts:

- RiskContext: snapshot of portfolio & limits.
- OrderIntent: pure description of a proposed order.
- RiskDecision: structured result of pre-trade / post-trade checks.

Design (you can use dataclasses or typed dicts):

1.1 OrderIntent
- Fields:
  - symbol
  - side ("BUY"/"SELL")
  - qty
  - quote_notional
  - leverage
  - strategy_id
  - tier_name
  - account_mode (cross/isolated if meaningful)
  - nav_usd (or nav context)
  - open_positions_count (global + per-symbol)
  - tier_gross_notional
  - any other fields risk_limits currently uses

1.2 RiskDecision
- Fields:
  - allowed: bool
  - clamped_qty: float (qty after min_notional / caps)
  - reasons: list[str]   (empty if allowed=True)
  - hit_caps: dict[str, bool]  (e.g. {"trade_equity_cap": True, "symbol_nav_cap": False})
  - diagnostics: dict    (optional, for logging/telemetry)

1.3 RiskEngineV6
- Functions / methods:
  - from_configs(risk_limits_config, pairs_universe_config) -> RiskEngineV6
  - check_order(intent: OrderIntent, positions_state: dict, nav_state: dict) -> RiskDecision
  - check_portfolio(nav_state: dict, positions_state: dict) -> RiskDecision or similar
  - build_risk_snapshot(nav_state, positions_state) -> dict
- Implementation detail:
  - Internally call the existing symbols_notional_guard, symbol_dd_guard, daily_loss_limit, etc. from execution/risk_limits.py.
  - Normalize their outputs into RiskDecision (reason strings, booleans, etc.).
  - Do NOT add new risk conditions; just wrap what’s there.

Constraints:
- RiskEngineV6 must be stateless and pure given inputs (no hidden globals).
- All numeric thresholds and caps must still come from config (risk_limits + pairs_universe).

======================================================================
2) Wiring: Screener + Executor (Flag-Gated)
======================================================================

Update:

- execution/signal_screener.py
- execution/executor_live.py
- execution/risk_limits.py (only to expose helpers to RiskEngineV6, not change logic)

Tasks:

2.1 Screener wiring
- Introduce a mode where would_emit() can call into RiskEngineV6:
  - Add a factory to construct RiskEngineV6 from configs.
  - Build an OrderIntent from screener context (symbol, strategy, proposed size/notional).
  - Call RiskEngineV6.check_order() and:
    - respect veto decisions,
    - propagate reasons in veto logs.
- Guard this with RISK_ENGINE_V6_ENABLED:
  - When flag is False, screener uses existing risk_limits path only.
  - When flag is True, screener uses RiskEngineV6 but must behave identically.

2.2 Executor wiring
- In executor_live.py, in the main order submission path:
  - Build an OrderIntent from the live order context (use the same intent fields as screener).
  - Call RiskEngineV6.check_order() when RISK_ENGINE_V6_ENABLED is True.
  - Apply:
    - clamped_qty (if engine reduces size) – but ONLY if it matches current behavior.
    - veto if allowed=False, with reasons logged exactly.
- Keep old path (direct calls into risk_limits) in place for:
  - RISK_ENGINE_V6_ENABLED=False, and/or
  - any emergency fallback.

2.3 Risk snapshot integration
- Use RiskEngineV6.build_risk_snapshot() as the single producer of risk_snapshot dicts:
  - called from executor telemetry hooks (or state_publish).
  - writes logs/state/risk_snapshot.json via state_publish.

Constraints:
- For this batch, RiskEngineV6 must be a **behavioural mirror** of existing risk_limits.
- If tests reveal any difference in decisions, adjust mapping until parity is achieved.

======================================================================
3) Tests
======================================================================

Create:

- tests/test_risk_engine_v6.py

Test scenarios:

1) Parity with risk_limits:
   - For a selection of synthetic OrderIntents (symbols, sizes, nav, tier contexts):
     - call old risk_limits path and RiskEngineV6.check_order().
     - assert: allowed matches, reasons match, clamped_qty matches.
   - Include:
     - hitting trade_equity_nav_pct caps,
     - hitting symbol NAV caps,
     - min_notional clamping,
     - daily loss limit.

2) Screener & executor parity:
   - For a given symbol/strategy scenario:
     - run screener would_emit() with RISK_ENGINE_V6_ENABLED=False and True.
     - assert identical decisions and reasons.
   - Similarly for executor flow (you can bypass actual order sending and call a helper if available).

3) Risk snapshot:
   - Given synthetic nav + positions + configs:
     - build risk_snapshot via RiskEngineV6.
     - assert it contains:
       - per-symbol exposures,
       - tier-level caps/usage,
       - drawdown info.
     - verify state_publish writes logs/state/risk_snapshot.json.

Extend existing tests:

- tests/test_risk_limits.py
  - Add sanity checks that RiskEngineV6 uses the same thresholds and reason codes.
- tests/test_screener_tier_caps.py
  - Ensure tier-cap enforcement is identical in v5 vs v6 risk modes.

Validation commands:

- New risk engine suite:

  python -m pytest \
    tests/test_risk_limits.py \
    tests/test_screener_tier_caps.py \
    tests/test_risk_engine_v6.py -q

- Core regression:

  python -m pytest \
    tests/test_risk_limits.py \
    tests/test_screener_tier_caps.py \
    tests/test_exchange_dry_run.py \
    tests/test_router_smoke.py \
    tests/test_router_policy.py \
    tests/test_router_metrics_effectiveness.py \
    tests/test_order_router_ack.py \
    tests/test_order_metrics.py \
    tests/test_config_parsing.py \
    tests/test_expectancy_v6.py \
    tests/test_symbol_score_v6.py \
    tests/test_router_autotune_v6.py \
    tests/test_feedback_allocator_v6.py \
    tests/test_risk_engine_v6.py -q

Constraints:

- Do NOT:
  - add new veto rules,
  - change numeric thresholds,
  - change risk semantics.
- v6 engine must be a structural wrapper, not a behavioral change.
- When RISK_ENGINE_V6_ENABLED is False, code paths and behavior must be indistinguishable from pre-Batch-7.
