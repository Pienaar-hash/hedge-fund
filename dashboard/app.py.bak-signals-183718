#!/usr/bin/env python3
from __future__ import annotations
"""
Streamlit dashboard (single Overview tab).
Read-only and fast. Firestore-first; falls back to local files.
Shows: KPIs, NAV chart, Positions, Signals, Trade log (5), Screener tail (10), Reserve.
"""

from dotenv import load_dotenv
load_dotenv()  # loads /root/hedge-fund/.env if present

import os, json, time, pathlib, re
from typing import Any, Dict, List, Optional

import pandas as pd
import streamlit as st

# --- constants / env ---
ENV = os.getenv("ENV", "prod")
RESERVE_BTC = 0.013  # display-only; do not inject into NAV
LOG_PATH = os.getenv("EXECUTOR_LOG", "/var/log/hedge-executor.out.log")
TAIL_LINES = 10

# ------------------------------ utils ----------------------------------------

def _load_json(path: str, default=None):
    try:
        with open(path, "r") as f:
            return json.load(f)
    except Exception:
        return default

# Robust timestamp parsing → epoch ms
from datetime import datetime, timezone

def _to_epoch_ms(t: Any) -> int:
    if t is None:
        return 0
    # int/float → heuristics
    if isinstance(t, (int, float)):
        # assume: >1e12 → ms, >1e9 → sec
        v = float(t)
        if v > 1e12:
            return int(v)
        if v > 1e9:
            return int(v * 1000)
        # sub-second epoch seconds
        if v > 1e3:
            return int(v)  # already ms-ish
        return int(v * 1000)
    # str: numeric, ISO8601, or Firestore repr
    if isinstance(t, str):
        s = t.strip()
        try:
            return _to_epoch_ms(float(s))
        except Exception:
            pass
        if s.endswith("Z"):
            s = s[:-1] + "+00:00"
        try:
            dt = datetime.fromisoformat(s)
            return int(dt.timestamp() * 1000)
        except Exception:
            # Firestore repr e.g. "Timestamp(seconds=..., nanoseconds=...)"
            m = re.search(r"seconds=(\d+)", s)
            if m:
                sec = int(m.group(1))
                m2 = re.search(r"nanoseconds=(\d+)", s)
                ns = int(m2.group(1)) if m2 else 0
                return int(sec * 1000 + ns / 1e6)
            return 0
    # dict: Firestore timestamp map
    if isinstance(t, dict):
        sec = t.get("seconds") or t.get("_seconds")
        ns = t.get("nanoseconds") or t.get("_nanoseconds") or 0
        try:
            return int(int(sec) * 1000 + int(ns) / 1e6)
        except Exception:
            return 0
    return 0


def _ts(v: Any) -> int:
    if isinstance(v, dict):
        t = v.get("t") or v.get("ts") or v.get("time") or v.get("timestamp")
    else:
        t = v
    return _to_epoch_ms(t)


def _val(v: Any) -> Optional[float]:
    if isinstance(v, dict):
        x = v.get("v", v.get("value", v.get("nav", v.get("equity"))))
    else:
        x = v
    try:
        return float(x)
    except Exception:
        return None

# ------------------------------ Firestore -------------------------------------

def _fs_client():
    try:
        from google.cloud import firestore
        return firestore.Client()
    except Exception:
        return None


def _fs_get_path(doc: str):
    # collection/doc/collection/doc path → hedge/{ENV}/state/{doc}
    return f"hedge/{ENV}/state/{doc}"


def _fs_get_state(doc: str):
    cli = _fs_client()
    if not cli:
        return None
    try:
        snap = cli.document(_fs_get_path(doc)).get()
        return snap.to_dict() if snap.exists else None
    except Exception:
        return None

# ------------------------------ Data sources ----------------------------------

def load_nav_series() -> List[Dict[str, Any]]:
    # Firestore first
    nav = _fs_get_state("nav")
    if isinstance(nav, dict):
        if "series" in nav and isinstance(nav["series"], list):
            return nav["series"]
        if "nav_series" in nav and isinstance(nav["nav_series"], list):
            return nav["nav_series"]
    if isinstance(nav, list):
        return nav
    # Local fallback
    peak = _load_json("peak_state.json", {})
    if isinstance(peak, dict):
        if isinstance(peak.get("nav_series"), list):
            return peak["nav_series"]
        if isinstance(peak.get("nav"), list):
            return peak["nav"]
    return []


def load_positions() -> List[Dict[str, Any]]:
    pos = _fs_get_state("positions")
    if isinstance(pos, dict) and "rows" in pos:
        rows = pos["rows"]
    elif isinstance(pos, list):
        rows = pos
    else:
        rows = []
    out: List[Dict[str, Any]] = []
    for r in rows:
        if not isinstance(r, dict):
            continue
        try:
            out.append({
                "symbol": r.get("symbol"),
                "side": r.get("positionSide") or r.get("side") or "BOTH",
                "qty": float(r.get("qty") or r.get("positionAmt") or 0),
                "entryPrice": float(r.get("entryPrice") or 0),
                "unrealized": float(r.get("unrealized") or r.get("uPnl") or r.get("unRealizedProfit") or 0),
                "leverage": float(r.get("leverage") or 0),
            })
        except Exception:
            continue
    return out


def _parse_log_tail(pattern: str, n: int) -> List[str]:
    try:
        with open(LOG_PATH, "r", errors="ignore") as f:
            lines = f.readlines()[-4000:]
    except Exception:
        return []
    matcher = re.compile(pattern)
    hits = [ln.rstrip("\n") for ln in lines if matcher.search(ln)]
    return hits[-n:]


def load_signals_table(n: int = 5) -> pd.DataFrame:
    pat = r"\\[screener->executor\\].*?(\{.*\})"
    raw = _parse_log_tail(pat, 80)
    rows: List[Dict[str, Any]] = []
    for ln in raw[-n:]:
        try:
            m = re.search(pat, ln)
            obj = json.loads(m.group(1)) if m else None
            if not obj:
                continue
            rows.append({
                "time": obj.get("timestamp") or obj.get("t"),
                "symbol": obj.get("symbol"),
                "tf": obj.get("timeframe"),
                "signal": obj.get("signal"),
                "price": obj.get("price"),
                "cap": obj.get("capital_per_trade"),
                "lev": obj.get("leverage"),
            })
        except Exception:
            continue
    return pd.DataFrame(rows)


def load_trade_log(n: int = 5) -> pd.DataFrame:
    # Prefer structured local file if present
    tl = _load_json("trade_log.json", [])
    rows: List[Dict[str, Any]] = []
    if isinstance(tl, list) and tl:
        for x in tl[-n:]:
            if not isinstance(x, dict):
                continue
            rows.append({
                "time": x.get("time") or x.get("ts"),
                "symbol": x.get("symbol"),
                "side": x.get("side"),
                "qty": x.get("qty"),
                "price": x.get("price"),
                "pnl": x.get("pnl"),
            })
        return pd.DataFrame(rows)
    # Fallback: parse ORDER_REQ lines for visibility
    pat = r"\\[executor\\]\\s+ORDER_REQ.*"
    raw = _parse_log_tail(pat, 60)[-n:]
    for ln in raw:
        rows.append({"time": "-", "symbol": "-", "side": "-", "qty": "-", "price": "-", "pnl": "-", "raw": ln})
    return pd.DataFrame(rows)

# ------------------------------ KPIs / NAV ------------------------------------

def compute_nav_kpis(series: List[Dict[str, Any]]) -> Dict[str, Any]:
    if not series:
        return {"nav": None, "nav_24h": None, "delta": 0.0, "delta_pct": 0.0, "dd": None}
    rows = [( _ts(x), _val(x)) for x in series if isinstance(x, dict)]
    rows = [(t, v) for (t, v) in rows if t and (v is not None)]
    if not rows:
        return {"nav": None, "nav_24h": None, "delta": 0.0, "delta_pct": 0.0, "dd": None}
    rows.sort(key=lambda x: x[0])
    nav_now = rows[-1][1]
    cutoff_ms = int((time.time() - 24*3600) * 1000)
    past_vals = [v for (t, v) in rows if t <= cutoff_ms]
    nav_24h = past_vals[-1] if past_vals else nav_now
    peak = max(v for _, v in rows)
    dd = 0.0 if not peak else (peak - nav_now) / peak * 100.0
    delta = nav_now - nav_24h
    delta_pct = (delta / nav_24h * 100.0) if nav_24h else 0.0
    return {"nav": nav_now, "nav_24h": nav_24h, "delta": delta, "delta_pct": delta_pct, "dd": dd}

# ------------------------------ UI -------------------------------------------

st.set_page_config(page_title="Hedge — Overview", layout="wide")
st.title("Hedge — Overview")
sub = f"ENV: {ENV} · Read-only dashboard"
st.caption(sub)

# KPIs
series = load_nav_series()
k = compute_nav_kpis(series)
c1, c2, c3, c4 = st.columns(4)
c1.metric("NAV (USDT)", f"{k['nav']:,.2f}" if k['nav'] is not None else "—", f"{k['delta']:,.2f} / {k['delta_pct']:+.2f}%")
c2.metric("Drawdown", f"{k['dd']:.2f}%" if k['dd'] is not None else "—")
c3.metric("Reserve (BTC)", f"{RESERVE_BTC}")
c4.metric("Tail lines", f"{TAIL_LINES}")

# NAV chart
if series:
    df = pd.DataFrame([
        {
            "ts": _ts(x),
            "nav": _val(x)
        } for x in series if isinstance(x, dict)
    ])
    # Convert epoch ms → pandas datetime
    df = df.dropna()
    if not df.empty:
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True, errors="coerce")
        df = df.dropna()
        st.line_chart(df.set_index("ts")["nav"])
    else:
        st.info("NAV series present but not parseable.")
else:
    st.info("No NAV series in Firestore; showing KPIs only (fallback mode).")

st.markdown("---")

# Positions
st.subheader("Positions")
pos = load_positions()
if pos:
    dfp = pd.DataFrame(pos)
    dfp = dfp.sort_values(by=["symbol", "side"]).reset_index(drop=True)
    st.dataframe(dfp, use_container_width=True, height=260)
else:
    st.write("No positions available in Firestore.")

# Signals
st.subheader("Signals (latest 5)")
st.dataframe(load_signals_table(5), use_container_width=True, height=210)

# Trade log
st.subheader("Trade Log (latest 5)")
st.dataframe(load_trade_log(5), use_container_width=True, height=210)

# Screener tail (last 10)
st.subheader("Screener Tail (last 10)")

tail: List[str] = []
for tag in (r"\[screener\]", r"\[decision\]", r"\[screener->executor\]"):
    tail.extend(_parse_log_tail(tag, TAIL_LINES))
# keep last 10 only
tail = tail[-TAIL_LINES:]
st.code("\n".join(tail) if tail else "(empty)")
