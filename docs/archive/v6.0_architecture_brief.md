# v6.0 Architecture Brief

- **Single executor binary** – `execution/executor_live.py:1-1745` owns signal intake, risk checks, router orchestration, telemetry, and intel refresh. Supervisor (`ops/hedge.conf:1-52`) simply keeps it alive with helper daemons for sync and pipeline compare; there are no hidden microservices.
- **Typed risk core** – `execution/risk_engine_v6.py:1-114` wraps `risk_limits.check_order()` so every intent produces a deterministic `RiskDecision`. The same object feeds live routing, the pipeline shadow harness, and state snapshots, ensuring parity across dry runs and production.
- **Telemetry-first runtime** – `_pub_tick()` (`execution/executor_live.py:3291-3358`) writes nav, positions, risk, symbol scores, router health, and a `synced_state.json` bundle using `execution/state_publish.py:77-190`. Downstream consumers (sync_state, dashboard, CLI probes) only read those files, so the runtime is fully observable from `logs/`.
- **Intel feedback loop** – The executor periodically calls `execution/intel/expectancy_v6.py:1-333`, `execution/intel/symbol_score_v6.py:1-137`, `execution/intel/router_autotune_v6.py:1-200`, and `execution/intel/feedback_allocator_v6.py:260-402` to refresh expectancy, scores, router suggestions, and risk allocation caps. Router auto-apply logic in `execution/intel/router_autotune_apply_v6.py:1-155` reads the resulting JSON to enforce small, reversible adjustments.
- **Shadow & compare built-in** – `execution/pipeline_v6_shadow.py:1-116` replays intents through `RiskEngineV6` + sizing without hitting the exchange, while `execution/intel/pipeline_v6_compare.py:1-98` aligns those decisions against `logs/execution/orders_executed.jsonl`. Heartbeats and diffs are persisted to `logs/state/pipeline_v6_shadow_head.json` and `logs/state/pipeline_v6_compare_summary.json` so v6 launch metrics stay auditable.
- **Ops simplicity** – Only five Supervisor programs run (executor, dashboard, sync_state, pipeline heartbeat, pipeline compare). Sync + dashboard read the same `logs/state/*.json` artifacts; there are no legacy dashboards or v5 multi-strategy entrypoints to keep in sync.

If you understand the modules highlighted above, you understand the whole runtime—every other package in the repo plugs into these surfaces.
