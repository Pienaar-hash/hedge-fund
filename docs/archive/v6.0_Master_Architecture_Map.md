# v6.0 Master Architecture Map

| Layer | Module(s) + line range | Inputs | Outputs | Notes |
| --- | --- | --- | --- | --- |
| Processes | `ops/hedge.conf:1-52` | Supervisor env, repo root | 5 programs (executor, dashboard, sync_state, pipeline heartbeat, pipeline compare) | Provides canonical PYTHONPATH/ENV context so every entrypoint resolves repo modules.
| Signal intake | `execution/signal_generator.py:1-210`, `execution/signal_screener.py:1-145` | Strategy registry (`config/strategy_registry.json`), ATR metrics, risk caps | Normalized intents w/ dedupe + ATR veto metadata | Screener also queries `execution.orderbook_features` and `RiskState` to ensure pre-trade risk parity.
| Execution loop | `execution/executor_live.py:1-1745` | Signals, `config/risk_limits.json`, `config/pairs_universe.json`, runtime flags (`execution/v6_flags.py:18-92`) | Orders via `execution.exchange_utils`, telemetry via `execution/state_publish` writers | `_maybe_publish_execution_intel()`, `_maybe_emit_risk_snapshot()`, `_maybe_write_v6_runtime_probe()` keep router/risk/intel payloads current.
| Risk engine | `execution/risk_engine_v6.py:1-114`, `execution/risk_limits.py:1-210` | NAV snapshots, RiskGate state (`logs/cache/risk_state.json`), universe metadata | `RiskDecision` objects (allow/veto reasons, cap diagnostics) | `RiskEngineV6` wraps legacy gates to expose consistent telemetry for pipeline shadow + intel.
| Routing | `execution/order_router.py:1-210`, `execution/intel/router_policy.py:1-120`, `execution/intel/router_autotune_apply_v6.py:1-155` | Signals, maker offset intel, router suggestions (`logs/state/router_policy_suggestions_v6.json`) | Live orders (maker/taker selection), router metrics | Auto-apply respects env flags (`ROUTER_AUTOTUNE_V6_ENABLED/APPLY_ENABLED`) and `SYMBOL_ALLOWLIST` to avoid unsolicited flips.
| Intel analytics | `execution/intel/expectancy_v6.py:1-333`, `execution/intel/symbol_score_v6.py:1-137`, `execution/intel/router_autotune_v6.py:1-200`, `execution/intel/feedback_allocator_v6.py:260-402` | `logs/execution/orders_executed.jsonl`, `logs/execution/order_metrics.jsonl`, router health snapshot, nav/risk state | `logs/state/expectancy_v6.json`, `symbol_scores_v6.json`, `router_policy_suggestions_v6.json`, `risk_allocation_suggestions_v6.json` | Executor refresh schedule is driven by `_LAST_INTEL_PUBLISH` timers (see `execution/executor_live.py:341-405`).
| Telemetry/logging | `execution/state_publish.py:77-190`, `execution/log_utils.py:1-150`, `execution/events.py:1-70` | Runtime payloads, event dicts | Atomic JSON state files under `logs/state/`, JSONL logs under `logs/execution/` | The same functions are imported into CLI probes so every tool writes identical schema.
| Shadow pipeline | `execution/pipeline_v6_shadow.py:1-116`, `scripts/pipeline_shadow_heartbeat.py:1-38`, `execution/intel/pipeline_v6_compare.py:1-98`, `scripts/pipeline_compare_service.py:1-33` | V6 signals, nav/positions snapshots, live fills | `logs/pipeline_v6_shadow.jsonl`, `logs/state/pipeline_v6_shadow_head.json`, `logs/pipeline_v6_compare.jsonl`, `logs/state/pipeline_v6_compare_summary.json` | Executor also emits heartbeat/shadow compare when enabled (see `execution/executor_live.py:1660-1718`).
| State sync/dashboard | `execution/sync_state.py:21-1258`, `dashboard/app.py:1-130` | Local logs/state, Firestore creds | Firestore docs (`hedge/{env}/state/*`), dashboard panels | Sync enforces NAV freshness, attaches drawdown stats, and writes `logs/state/nav.json`, `positions.json`, etc., which Streamlit renders.

## Data flow narrative
1. **Signals** are generated, deduped, and risk-sanitized (`execution/signal_generator.py:1-210`, `execution/signal_screener.py:1-145`).
2. **Executor** ingests intents, loads runtime configs, enforces v6 flags, and either routes orders or mirrors them into the shadow pipeline (`execution/executor_live.py:1-1745`).
3. **Risk enforcement** happens twice: inline via `RiskState` + `risk_limits.check_order()` and again via the typed `RiskEngineV6` wrapper for telemetry and pipeline parity (`execution/risk_engine_v6.py:1-114`).
4. **Routing** chooses maker vs taker, applies offsets, and logs metrics to `logs/execution/order_metrics.jsonl` while optionally auto-applying router suggestions (`execution/order_router.py:1-210`, `execution/intel/router_autotune_apply_v6.py:1-155`).
5. **Telemetry** is flushed every `_pub_tick()` to `logs/state/*.json` (nav, positions, risk snapshot, router health, intel) and `logs/execution/*.jsonl` (orders executed, router metrics, risk vetoes) using the canonical writers in `execution/state_publish.py:77-190`.
6. **Shadow + compare** continuously replay fresh intents through `pipeline_v6_shadow` and compare the output against real fills so v6 gating can launch safely (`execution/pipeline_v6_shadow.py:1-116`, `execution/intel/pipeline_v6_compare.py:1-98`).
7. **Intel analytics** consume on-disk telemetry to produce expectancy, symbol scores, router suggestions, and risk allocation caps that the executor and router can act upon in the next loop (`execution/intel/*.py`).
8. **Sync + dashboard** read exactly the same files the executor writes; `execution/sync_state.py:21-1258` pushes nav/positions/leaderboard to Firestore, while `dashboard/app.py:1-130` renders the local state set with no hidden APIs.

## Canonical artifacts
- Logs: `logs/execution/orders_executed.jsonl`, `logs/execution/order_metrics.jsonl`, `logs/router_health.jsonl`.
- State: `logs/state/nav.json`, `positions.json`, `risk_snapshot.json`, `router_health.json`, `expectancy_v6.json`, `symbol_scores_v6.json`, `router_policy_suggestions_v6.json`, `risk_allocation_suggestions_v6.json`, `pipeline_v6_shadow_head.json`, `pipeline_v6_compare_summary.json`, `v6_runtime_probe.json`, `synced_state.json`.
- Config: `config/risk_limits.json`, `config/pairs_universe.json`, `config/runtime.yaml`, `config/strategy_registry.json`.

Every module and path above is present in this repo snapshot; there are no sidecar dependencies beyond the declared configs, logs, and state files.
