# GPT-Hedge v7.4 â€” Preflight Runbook (Mainnet + Dry Run)

Mode: **Mainnet infrastructure, DRY_RUN enabled, no testnet endpoints.**  
Goal: Run the full v7.4 engine against mainnet data and state, while **blocking real orders** via DRY_RUN.

---

## 0. Mental Model â€” Modes

We operate in 3 conceptual modes:

1. **Dev / Local** â€” arbitrary, can point anywhere.
2. **Mainnet + DRY_RUN = TRUE** â† **THIS RUNBOOK**
   - Real mainnet market data, balances, NAV.
   - **No orders actually hit the exchange.**
3. **Mainnet Live (DRY_RUN = FALSE)** â€” future step, separate runbook.

Testnet is **not** part of this runbook. All checks below assume **mainnet credentials + URLs**.

---

## 1. Environment Sanity â€” No Testnet, DRY_RUN On

### 1.1 Check `.env` and ENV flags

From repo root:

```bash
grep -E 'ENV=|DRY_RUN=|TESTNET|BINANCE' .env || sed -n '1,50p' .env
````

Requirements:

* `ENV=prod` or `ENV=mainnet` (whatever your convention is)
* `DRY_RUN=1`  (or `true` / `True`, but must resolve to **True** in code)
* **No** `BINANCE_TESTNET=1` (if variable exists, it must be `0` or `false`)
* If you have a `BASE_URL`/`BINANCE_BASE_URL`, it should be **mainnet**, e.g.:

  * `https://fapi.binance.com`
  * **Not** `https://testnet.binancefuture.com` or similar.

### 1.2 Confirm runtime logs show mainnet, not testnet

Start any small command that uses your exchange util (exutil) or executor, then inspect logs:

```bash
grep -E 'exutil] base=' -n logs/system.log | tail -n 5
```

You want to see something like:

```text
[exutil] base=https://fapi.binance.com testnet=False
[exutil] ENV context testnet=False dry_run=True
```

**Reject** any of this:

* `testnet=True`
* `base=https://testnet...`

If that appears, **fix config and restart** before proceeding.

---

## 2. Processes & Supervisor

### 2.1 Supervisor status

```bash
sudo supervisorctl status | grep hedge
```

Expect:

* `hedge-executor` â€” RUNNING
* `hedge-sync_state` â€” RUNNING
* `hedge-dashboard` â€” RUNNING
* `hedge-pipeline-shadow-heartbeat` / compare processes â€” optional but nice-to-have

If anything is `EXITED`/`FATAL`, fix that **before** dry-run mainnet.

### 2.2 Confirm DRY_RUN in executor logs

Tail the executor log:

```bash
tail -n 50 logs/executor.log | sed -n '1,50p'
```

Check for a line that explicitly states:

* `ENV context testnet=False dry_run=True`
* Or equivalent single source of truth.

If DRY_RUN does **not** show as True, do **not** continue.

---

## 3. NAV, DD Circuit & Correlation Caps (Mainnet Balances)

Weâ€™re now reading **real** mainnet balances, but still not trading.

### 3.1 Sync and inspect NAV state

```bash
python execution/sync_state.py
jq '.risk | {portfolio_dd_pct, circuit_breaker}' logs/state/risk.json
```

Check:

* `portfolio_dd_pct` is sane for your mainnet account (likely small).
* `circuit_breaker.active == false` unless you *know* youâ€™re in >10% DD.

If circuit is active unexpectedly:

* Check `nav_log.jsonl` for odd jumps or stale history.
* Confirm no incorrect manual edits or replay files.

### 3.2 Correlation exposure sanity

```bash
jq '.risk.correlation_groups' logs/state/risk.json
```

For each group:

* `gross_nav_pct` should reflect **real mainnet positions** (if any).
* Should be well below `max_group_nav_pct` in a fresh DRY_RUN phase.

On dashboardâ€™s risk panel you should see:

* Correlation groups with ðŸŸ¢ **OK** status.
* No surprise ðŸŸ¡ NEAR / ðŸ”´ CAPPED unless you intentionally hold clustered risk on mainnet.

---

## 4. Hybrid Scores & Vol Regimes vs Mainnet Data

We now sanity check that alpha + regimes behave sensibly **on real mainnet feeds**.

### 4.1 Inspect a core symbol (e.g., BTCUSDT)

```bash
jq '.intel["BTCUSDT"] | {trend_score, carry_score, hybrid_score, vol_regime}' logs/state/intel.json
```

Check:

* Scores are in [-1, 1].
* `vol_regime` is one of: `low`, `normal`, `high`, `crisis`.

Interpretation:

* If funding is strongly positive and basis favorable â†’ **carry_score > 0**.
* Hybrid should align with our intuition:

  * Strong trend + positive carry â†’ decent positive `hybrid_score`.
  * Choppy trend + expensive carry â†’ low or negative `hybrid_score`.

### 4.2 Dashboard â€” Intel/Advanced tabs

Open:

```bash
streamlit run dashboard/app.py
```

Look at:

* **Hybrid Scores panel**:

  * Top-ranked symbols should be plausible leaders (majors, liquid alts).
* **Carry panel**:

  * You should see a mix of positive/negative carry consistent with current funding.
* **Vol Regimes panel**:

  * Majority of symbols `normal` / `high` depending on market conditions.
  * `crisis` only for extreme volatility.

---

## 5. Execution Layer â€” Confirm DRY_RUN + TWAP Behaviour

We want to ensure:

* Router is set to mainnet.
* DRY_RUN ensures **no live orders**.
* Logic still routes, logs, and TWAPs **as if** live.

### 5.1 Confirm TWAP config

```bash
yq '.router.twap' config/runtime.yaml
```

Check:

* `enabled: true` (if you want TWAP behaviour tested).
* `min_notional_usd` sized appropriately for **your live NAV**.
* `slices` / `interval_seconds` reasonable (e.g., 4 / 10).

### 5.2 Trigger a test signal (dry-run mainnet)

Manually or via screener, generate a signal that would produce a trade with `gross_usd >= min_notional_usd`.

Then check router/exec logs:

```bash
tail -n 50 logs/executor.log
tail -n 50 logs/router.log
```

Expect:

* Full intent, risk checked, router path taken.
* Log lines showing DRY_RUN preventing actual API send.

### 5.3 Check TWAP events (logic-only)

```bash
tail -n 20 logs/execution/twap_events.jsonl
```

You should see:

* `execution_style: "twap"`
* `slice_index / slice_count`
* `slice_qty` matching expected splits.
* **No real trades on Binance** (because DRY_RUN swallows order sends).

If you see **single** style where you expected TWAP:

* Confirm `gross_usd` vs `min_notional_usd`.
* Confirm TWAP config and `enabled: true`.

---

## 6. No-Testnet Guardrails

We explicitly **do not** want any testnet code paths.

Add and follow these house rules:

1. `.env` MUST contain:

   * `BINANCE_TESTNET=0` (or not set at all; but never 1)
   * `ENV=prod` / `ENV=mainnet`
   * `DRY_RUN=1`

2. CI or local guard:

   * Add a **simple check** in your startup script / supervisor command:

     ```bash
     python scripts/assert_env_mainnet_dry_run.py
     ```

     Example assertions this script should enforce:

     * Environment base URL is **not** a testnet URL.
     * `DRY_RUN` is true when `ENV in {prod, mainnet}` and you are in this phase.
     * Log a loud error and `sys.exit(1)` if any testnet flag is detected.

3. Logs:

   * Before every serious dry-run session, explicitly log one line to `system.log`:

     ```text
     [preflight] v7.4 mainnet + DRY_RUN=True testnet=False
     ```

   * This becomes a clear audit marker in log history.

---

## 7. Final Preflight Checklist â€” Mainnet + DRY_RUN

Before you let v7.4 run unattended on mainnet with DRY_RUN:

* [ ] `.env` â†’ `ENV=prod/mainnet`, `DRY_RUN=1`, `BINANCE_TESTNET=0`.
* [ ] Logs show: `testnet=False dry_run=True` on startup.
* [ ] `PYTHONPATH=. pytest` â†’ **159 tests passing**.
* [ ] `risk.json`:

  * `circuit_breaker.active == false`
  * `portfolio_dd_pct` sensible for your real mainnet NAV.
  * `correlation_groups` all under caps.
* [ ] `intel.json`:

  * `trend_score`, `carry_score`, `hybrid_score`, `vol_regime` populated for core symbols.
* [ ] Dashboard:

  * Risk panel, Hybrid/Carry panel, Vol Regimes panel, Execution panel all render without schema errors.
* [ ] Router:

  * TWAP events and metrics present **but DRY_RUN prevents real trading**.

If all of the above are green, GPT-Hedge v7.4 is safe to run against **mainnet data** in **DRY_RUN mode**, before flipping DRY_RUN=0.

```
