# v7.6 Architecture

## Runtime Flow (live loop)
- Screener → `risk_limits.check_order` → `order_router.route_intent` → `executor_live` sends/monitors orders.
- Positions + TP/SL: `position_ledger` merges `positions_state.json` with TP/SL registry; `exit_scanner` evaluates exits and updates diagnostics.
- State publishing: `state_publish` writes atomic JSON to `logs/state/*` every executor loop; `sync_state` mirrors nav for dashboard.
- Dashboard: `dashboard/state_v7.py` loaders read state files; panels render NAV/positions/ledger/diagnostics.

## Module Boundaries
- `execution/` — live trading runtime (executor_live, order_router, risk_limits, exit_scanner, position_ledger, state_publish, diagnostics_metrics).
- `dashboard/` — loaders and panels for state surfaces.
- `config/` — strategy/risk/runtime configs.
- `tests/` — unit/integration/runtime lanes with markers.

## Canonical State Surfaces (single writer per file)
| File | Path | Writer | Frequency | Purpose |
|------|------|--------|-----------|---------|
| `nav.json` | `logs/state/nav.json` | executor → `write_nav_state` | per loop | NAV totals + exec stats |
| `nav_state.json` | `logs/state/nav_state.json` | sync_state | per sync | Dashboard NAV/AUM/drawdown snapshot |
| `positions_state.json` | `logs/state/positions_state.json` | executor → `write_positions_state` | per loop | Normalized live positions |
| `positions_ledger.json` | `logs/state/positions_ledger.json` | executor → `write_positions_ledger_state` | per loop | Unified positions + TP/SL registry |
| `kpis_v7.json` | `logs/state/kpis_v7.json` | executor → `write_kpis_v7_state` | per loop | Portfolio + per-symbol KPIs |
| `diagnostics.json` | `logs/state/diagnostics.json` | executor → `write_runtime_diagnostics_state` | per loop | Veto counters, exit coverage, liveness |
| `risk_snapshot.json` | `logs/state/risk_snapshot.json` | executor → `write_risk_snapshot_state` | per loop | Risk KPIs (dd_state, risk_mode, VaR/CVaR) |
| `router_health.json` | `logs/state/router_health.json` | executor → `write_router_health_state` | per loop | Router quality stats |
| `symbol_scores_v6.json` | `logs/state/symbol_scores_v6.json` | executor → `write_symbol_scores_state` | per intel run | Hybrid scores/factors |
| `rv_momentum.json` | `logs/state/rv_momentum.json` | executor → `write_rv_momentum_state` | per intel run | Relative value momentum |
| `factor_diagnostics.json` | `logs/state/factor_diagnostics.json` | executor → `write_factor_diagnostics_state` | per intel run | Factor weights/covariance/orthogonalization |

Factor diagnostics (v7.6) now publishes a full analytics surface: raw factors, normalization coefficients, normalized vectors, Gram–Schmidt orthonormal basis (with degeneracy flags), covariance/correlation + volatilities, IR surfaces, smoothed/clamped weights, and a pnl_attribution block keyed by the configured lookback. NAV/risk surfaces are hardened with nav anomaly guards, dd_state governance, and VaR/CVaR limit flags flowing into risk_snapshot.json.

## Liveness & Diagnostics Signals
- Veto counters: signals/orders/veto reasons with timestamps.
- Exit pipeline: last scan/trigger, coverage %, ledger/registry mismatch, underwater-without-TP/SL count, last router event.
- Liveness: idle flags for signals/orders/exits/router; missing timestamps treated as idle; durations in seconds.

## Data Provenance
- Executor is canonical writer for all runtime state except `nav_state.json` (sync_state mirror).
- TP/SL registry + positions merged only via `position_ledger`; never mutate `positions_state.json` elsewhere.
- Dashboard is read-only; no module besides executor/state_publish writes under `logs/state/`.
- Router microstructure: `order_router.RouterStats` accumulates slippage/latency/TWAP usage per symbol; `executor_live` passes snapshots into `state_publish.write_router_health_state`, which emits `router_health.json` with global + per-symbol quality buckets.
