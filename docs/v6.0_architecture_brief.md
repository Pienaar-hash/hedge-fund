v6.0 architecture brief

---

## 1. v6.0 Objectives

**Primary goal:**
Evolve the current v5.10 execution stack into **v6.0** with *safer risk*, *clearer separation of responsibilities*, and *clean multi-strategy support* — **without** breaking the hardened v5.10 behavior.

**Key objectives:**

1. **Deterministic execution layer**

   * Single, well-defined path from: *signal → gate → size → route → order → state → telemetry*.
   * No hidden quote hacks, no per-symbol “surprises”.

2. **First-class multi-strategy support**

   * Multiple strategies can share the same symbol and wallet with:

     * Clean per-strategy PnL, sizing, and risk overlays.
     * No cross-contamination in risk or metrics.

3. **Centralized, coherent risk**

   * All risk rules (gross, symbol caps, leverage, min-notional, daily loss) enforced via **one canonical gate**.
   * Config schemas that exactly match what the code reads.

4. **Router & venue abstraction**

   * Router policy actually drives maker/taker behavior.
   * Clear ability to add:

     * Internal synthetic venues (paper, sim, sandbox).
     * Future real venues if needed.

5. **Transparent state & telemetry**

   * NAV, reserves, positions, and router health:

     * Single canonical sources.
     * Streamlined state publishing for dashboard + logs.

6. **Agent/Codex-friendly topology**

   * Stable surfaces for:

     * Audits
     * Patching
     * Strategy experiments
   * Clear boundaries so agents can’t silently break risk/execution.

---

## 2. High-Level Changes vs v5.10

> Current-state repo inventory lives in `docs/ARCHITECTURE_CURRENT.md` and the deeper audit in `docs/infra_v6.0_repo_topology.md`. Everything below describes the **target v6.0 design**; any “current” gaps noted come from those references.

What **v6.0 adds** on top of hardened v5.10:

1. **Execution pipeline as an explicit graph**

   * v5.10: pipeline is mostly implied in executor_live.py.
   * v6.0: small orchestrator that calls named stages:

     ```text
     generate_intents → strategy_gate → risk_gate → size_model → router → exchange
     ```

2. **Strategy layer extraction**

   * v5.10: strategies are config + ad-hoc generate_intents logic.
   * v6.0: strategies register via a **strategy registry interface** so:

     * Screener/loader can see what’s live.
     * Each strategy can run with its own parameters and tags.

3. **Unified risk engine**

   * v5.10: risk_limits + scattered guards.
   * v6.0: single `RiskEngine` object that:

     * Loads config
     * Caches per-symbol limits
     * Provides `check_order` and `check_nav` APIs used everywhere.

4. **Router policy actually in charge**

   * v5.10: RouterPolicy exists but only partly used (maker_first).
   * v6.0: router policy drives:

     * maker vs taker
     * adaptive offset bounds
     * venue choice (real vs paper)
   * Router state is exposed cleanly into telemetry.

5. **Telemetry & dashboard contracts**

   * v5.10: “works”, but some files drift (pairs_universe vs strategy_config vs risk_limits).
   * v6.0: one canonical “universe snapshot” structure:

     ```json
     {
       "symbol": "BTCUSDT",
       "tier": "CORE",
       "max_leverage": 20,
       "min_notional": 100,
       "caps": { ... }
     }
     ```
   * Dashboard reads this instead of half a dozen config files.

---

## 3. Architecture Layers (v6.0)

> `execution/executor_live.py` still drives the v5.10 pipeline described in `docs/ARCHITECTURE_CURRENT.md` §2; the sections below capture the intended v6.0 layering.

### 3.1 Config & Universe Layer

_Current status: `config/strategy_config.json` still mixes strategy knobs with exposure limits, and no generated `universe.json` exists (`docs/ARCHITECTURE_CURRENT.md` §3; `docs/infra_v6.0_repo_topology.md` §§2–3)._

**Goal:** Single source of truth for “what we trade” and “how hard we’re allowed to push”.

**Key artifacts:**

* `config/strategy_config.json`

  * Per-strategy configs only (no universe / risk inside).
  * Fields: `symbol`, `timeframe`, `params`, `enabled`, tags (e.g. `"bucket": "CORE"`).

* `config/risk_limits.json`

  * Canonical risk schema:

    ```json
    {
      "global": {
        "daily_loss_limit_pct": 5,
        "max_gross_exposure_pct": 150,
        "max_symbol_exposure_pct": 40,
        "max_leverage": 4,
        "min_notional_usdt": 100
      },
      "per_symbol": {
        "BTCUSDT": {
          "max_nav_pct": 0.08,
          "max_order_notional": 80000,
          "max_leverage": 3
        }
      }
    }
    ```

* `config/pairs_universe.json`

  * Pure metadata for dashboard/telemetry, **derived** from risk + tiers.
  * v6.0: either *generated* from a script or validated by tests against risk and strategy config.

* `execution/universe_resolver.py`

  * Single function / class that builds an in-memory universe:

    ```python
    UniverseEntry(
        symbol="BTCUSDT",
        tier="CORE",
        max_leverage=20,
        min_notional=100,
        risk_caps=...
    )
    ```
  * Used consistently by:

    * screener
    * risk engine
    * dashboard publisher

---

### 3.2 Strategy & Screener Layer

_Current status: `execution/signal_generator.py` loads hard-coded strategy modules, and the `strategies/` package plus registry loader do not exist yet (`docs/ARCHITECTURE_CURRENT.md` §§3–4)._

**Goal:** Pluggable strategies with stable interfaces.

**Core components:**

* `config/strategy_registry.json`

  * Lists strategy IDs + Python entrypoints:

    ```json
    {
      "strategies": {
        "btc_micro": {
          "module": "strategies.btc_micro",
          "class": "BTCMicroStrategy",
          "enabled": true
        }
      }
    }
    ```

* `strategies/` package

  * Each strategy implements an interface like:

    ```python
    class BaseStrategy:
        id: str
        symbol: str

        def generate_intents(self, market_data, state) -> list[Intents]:
            ...
    ```

* `execution/screener.py`

  * Orchestrates:

    * Load strategy registry
    * Instantiate enabled strategies
    * Evaluate entry gates
    * Emit **typed intents**:

      ```python
      Intent(
          strategy_id="btc_micro",
          symbol="BTCUSDT",
          side="BUY",
          meta={...}
      )
      ```

* `scripts/screener_probe.py`

  * Dev-only script to:

    * List strategies
    * Force-run screeners
    * Show gate vetoes + reasons

---

### 3.3 Risk Engine & Gates

_Current status: module-level helpers in `execution/risk_limits.py` stand in for the `RiskEngine` class; executor callers also skip several context fields per `docs/infra_v6.0_repo_topology.md` §2.1._

**Goal:** One place where all portfolio and per-order constraints live.

**Core elements:**

* `execution/risk_limits.py`

  * Implements a `RiskEngine`:

    ```python
    class RiskEngine:
        def check_order(self, order_ctx) -> tuple[bool, dict]:
            ...
        def check_nav(self, nav_ctx) -> tuple[bool, dict]:
            ...
    ```
  * `order_ctx` includes:

    * symbol, side, quantity, notional
    * pre-trade gross exposure estimates
    * strategy metadata

* Gating flow:

  1. Intent comes from strategy.
  2. Sizer proposes qty / leverage.
  3. RiskEngine applies:

     * min_notional
     * per-symbol max_nav_pct
     * max_order_notional
     * gross exposure caps
     * daily loss / drawdown stops
  4. Returns `(veto, details)` to executor.

* All call-sites use the same interface:

  * No ad-hoc if/else gates in random modules.

---

### 3.4 Sizer & Position Model

_Current status: `execution/size_model.py` enforces nav percentages but still depends on overlapping config data; telemetry lacks the canonical universe inputs described here._

**Goal:** Clear mapping from nav, risk, and strategy config → order size.

* `execution/size_model.py`

  * Encodes the *policy* for:

    * per-symbol target exposure
    * per-trade sizing
    * per-strategy scaling
  * Receives:

    * strategy config params
    * current nav / volatility
    * symbol risk caps (from `RiskEngine` or Universe)

* v6.0 ensures:

  * leverage computations **always** read from one place.
  * If per-symbol override exists, it’s consistent across:

    * risk_limits
    * pairs_universe
    * size_model

---

### 3.5 Router & Exchange Layer

_Current status: routers/intel exist but omit the maker/taker/fallback fields and router autotune loops described in `docs/infra_v6.0_repo_topology.md` §§2.1, 6._

**Goal:** Router policy → actual order routing decisions, no hidden rules.

* `execution/order_router.py`

  * Accepts an “order request” object:

    ```python
    OrderRequest(
        symbol="BTCUSDT",
        side="BUY",
        type="LIMIT",
        qty=0.01,
        price=...,
        meta={"strategy_id": "...", "intent_id": "..."}
    )
    ```
  * Applies:

    * RouterPolicy.maker_first
    * RouterPolicy.taker_bias
    * Adaptive offsets
    * Venue routing (real vs paper vs sandbox)

* `execution/exchange_utils.py`

  * Responsible only for:

    * symbol filters
    * rounding to stepSize/tickSize
    * signing, retries, and error classification
  * v6.0: no symbol-specific hacks for quotes or positionSide outside of strictly Binance-required bits.

* **Venue abstraction**

  * Later in v6.x we can support:

    * `venue="binance_futures"`
    * `venue="paper"`
    * `venue="sim"`
  * v6.0 just prepares API boundaries so this can be added safely.

---

### 3.6 State, NAV & Telemetry

_Current status: `_mirror_router_metrics` and `_maybe_publish_*` hooks are stubs, Firestore writers are disabled, and dashboards ingest JSONL files directly (`docs/ARCHITECTURE_CURRENT.md` §§2–4)._

**Goal:** Single true view of positions, NAV, and reserves.

* `execution/state_publish.py`

  * Reads:

    * live positions from exchange
    * universe metadata
    * NAV & reserves files
  * Publishes:

    * positions.json
    * router_health.json
    * nav.json / reserves.json
    * maybe `universe.json` with all per-symbol caps

* `dashboard/` code

  * Treats telemetry as **read-only contracts**:

    * never infers risk or leverage from raw positions
    * reads from structured telemetry files

* `scripts/doctor.py`

  * Keeps v6.0 checks:

    * nav freshness
    * drawdown
    * Firestore
    * router health
    * risk-state age

---

### 3.7 Agent / Codex Interfaces

_Current status: This doc plus `docs/infra_v6.0_repo_topology.md` act as the interim guidance until `docs/AGENT_SURFACES_v6.md` is created._

**Goal:** Make it safe and predictable for Codex & GPT to patch / audit.

* `docs/AGENT_SURFACES_v6.md` (we can create this)

  * Documents:

    * What configs agents may alter (and how).
    * Which modules they can audit or patch.
    * Required tests per scope (e.g., risk-only patch must run risk tests, etc.)

* Clear patch categories:

  * **Config-only**: adjust caps, universe, sizing.
  * **Strategy-only**: change signals, parameters.
  * **Infra-only**: router, risk engine internals.
  * Each category defines:

    * Allowed files
    * Required test commands
    * Required doctor checks

---

## 4. Migration Batches Overview

Reference `docs/infra_v6.0_repo_topology.md` §7 for the detailed backlog. Summaries:

1. **Batch 0 — Doc/topology alignment (this patch)**
   - Align architecture docs with current repo state (`docs/ARCHITECTURE_CURRENT.md`, this brief, and `docs/v6.0_Master_Architecture_Map.md`), ensuring terminology and references are concrete.
2. **Batch 1 — Config schema normalization**
   - Split strategy-only config from risk/universe data, introduce a generated `universe.json`, and update config/tests accordingly.
3. **Batch 2 — Execution & risk contract clarity**
   - Implement the `RiskEngine` object, ensure executor passes full context, and extend router metrics/telemetry fields needed for v6 sizing + expectancy feedback.
4. **Batch 3 — Telemetry & dashboard truthfulness**
   - Bring `_mirror_router_metrics`/`_maybe_publish_*` paths to life, wire Firestore/S3 (or local) publishers, and update dashboards to read canonical telemetry instead of config fallbacks.
5. **Batch 4 — DevOps & CI readiness**
   - Populate `infrastructure/` assets, fix `.github/workflows/ci.yml` dependency references, provide `.env.example`, and verify supervisor/cron coverage for sync + telemetry services.

---

## 5. Rollout Plan for v6.0

We can frame v6.0 rollout as **three stages**:

### Stage 1 — v6.0-alpha (shadow / dev)

* Introduce:

  * RiskEngine
  * UniverseResolver 2.0
  * StrategyRegistry interface
* Keep executor using the **existing** logic, but:

  * Add *shadow* calls to new components
  * Log differences vs legacy behavior
* No changes to:

  * live order submission
  * risk gating used in production

### Stage 2 — v6.0-beta (dual-path in prod)

* Add a feature flag in settings:

  * `execution_pipeline: "v5" | "v6"`
* Run:

  * `v6` pipeline in **simulation mode**:

    * computes what it *would* trade
    * logs hypothetical orders & vetoes
* Compare:

  * v5 actual trades vs v6 hypothetical
  * Validate risk, leverage, and exposure alignment

### Stage 3 — v6.0-prod cutover

* Once we’re satisfied:

  * Flip `execution_pipeline` to `"v6"`.
  * Keep:

    * kill-switch
    * risk hard veto
  * Keep a fallback option:

    * ability to revert pipeline to `"v5"` config-level without code changes.

---

## 6. Non-Goals for v6.0

To keep scope sane:

* No new venues (e.g., Bybit, OKX). Just prepare abstraction.
* No new asset universes (stick with hardened USDT majors & chosen alts).
* No new complex strategies (ICT / RL) in the **core** execution loop:

  * They can be prototyped in a separate `research/` pipeline and then plugged in.
