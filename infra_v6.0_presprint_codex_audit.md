# infra_v6.0_presprint_codex_audit.md

## BLOCKERS
- **Executor bypasses concurrency/tier caps.** `_send_order` calls `check_order()` without `open_positions_count`, `tier_name`, or `current_tier_gross_notional`, so the guards at `execution/risk_limits.py:1124-1144` never fire for live trades; only the screener path passes those inputs. As a result, `max_concurrent_positions`, derived per-tier budgets, and tier veto telemetry are silently ignored while `execution/executor_live.py:1717-1729` continues opening positions.
- **Router policy operates blind.** The router metrics emitted at `execution/order_router.py:620-682` contain price/qty/timing but omit `is_maker_final` and `used_fallback`. Yet `execution/utils/metrics.py:222-239` assumes those fields exist when computing router effectiveness, so maker/fallback ratios always read as zero and `execution/intel/router_policy.py:15-62` never downgrades quality. Maker/taker bias therefore never adapts in production, defeating the v5.10 policy engine.
- **Execution telemetry is stubbed.** `_mirror_router_metrics`, `_maybe_publish_execution_health`, `_maybe_emit_execution_alerts`, and `_maybe_publish_execution_intel` all return immediately (`execution/executor_live.py:94-107`). Nothing pushes order/router metrics, health payloads, or alerts to Firestore/telemetry, so operations cannot monitor NAV freshness, router KPIs, or maker/taker outcomes heading into v6.0.

## WARNINGS
- **Risk reason strings are misleading.** Both `check_order()` and `would_emit()` append the literal reason `"trade_gt_10pct_equity"` even when config sets the clamp elsewhere (`execution/risk_limits.py:1079-1104`, `execution/signal_screener.py:373-378`). Dashboards and probes now display “10%” while `config/risk_limits.json:4-26` actually enforces 15–20% caps.
- **Orderbook gating is hard-coded.** Screener orderbook alignment flags still trigger at ±0.20 imbalance (`execution/signal_screener.py:313-324`). With dual-hedge execution and router offsets tuned by policy, this threshold should live in `config/strategy_config.json` but remains buried in code.
- **Per-symbol share & drawdown guards are not configurable.** `SYMBOL_NOTIONAL_CAP = 0.25` and `SYM_DD_CAP_PCT = 3.0` sit in module globals (`execution/risk_limits.py:36-45`, `execution/risk_limits.py:1549-1565`). Any shift in NAV or reserve mix requires a code deploy rather than a config change.
- **Min-notional config mismatch.** `risk_limits.global.min_notional_usdt` is 100 USDT (`config/risk_limits.json:4-26`), but the sizing floors feeding intents remain 10–15 USDT (`config/strategy_config.json:12-43`). When NAV dips below ~600 USD the sizer path (`execution/size_model.py:229-320`, `execution/executor_live.py:1240-1423`) keeps emitting sub-100 orders that immediately get vetoed, causing repeated noisy blocks.
- **Strategy config duplicates concurrency keys.** Each enabled strategy includes both `"max_concurrent_positions": 3` and a second `"max_concurrent_positions": 1` entry (`config/strategy_config.json:101-138`). JSON keeps only the last value, but reviewers have no idea which is honored, and the derived `_strategy_concurrency_budget()` logic inherits the silent override.
- **USDC reduce-only closes are blocked.** `_CLOSE_POSITION_QUOTES` omits USDC, so hedge-mode reduce-only LIMIT/STOP orders on USDC-quoted perps never flip into `closePosition` (`execution/exchange_utils.py:1039-1105`). Any stop that requires the `closePosition` flag will therefore reject for USDC pairs.

## SAFE
- **Risk contract fidelity.** `check_order()` returns `(veto: bool, detail: dict)` with nav freshness flags, thresholds, and observed trade NAV (`execution/risk_limits.py:712-1205`), and regression tests such as `tests/test_risk_limits.py:97-207` cover the nav warning, trade-equity clamp, symbol caps, leverage overrides, cooldowns, and circuit breakers.
- **Screener wiring.** `would_emit()` applies listing, orderbook, concurrent/tier caps, and then shells out to `check_order()` while surfacing structured detail in `extra['risk']` (`execution/signal_screener.py:300-416`). `scripts/screener_probe.py:27-52` simply wraps that call, so probe output matches screener veto semantics.
- **Sizer parity.** `size_model.suggest_gross_usd()` respects per-bucket caps, per-symbol nav pct, trade-equity nav pct, `max_trade_nav_pct`, and leverage caps (`execution/size_model.py:229-320`). The executor then enforces the same snapshot before dispatch (`execution/executor_live.py:1240-1445`), so intentions, screener decisions, and live sizing stay consistent.
- **Router policy hooks exist.** The executor tags each router intent with `router_policy` metadata and maker-first context (`execution/executor_live.py:2034-2084`), while `route_order()` actually honors `RouterPolicy.maker_first` vs `taker_bias` and records the chosen path via `router_ctx['routed_as']` (`execution/order_router.py:474-585`). `tests/test_router_smoke.py:41-108` exercises those branches, and `tests/test_order_router_ack.py:1-27`/`tests/test_order_metrics.py:1-55` keep ACK + telemetry formatting honest.
- **Config/tests guardrails.** Load/format checks exist for both `strategy_config.json` and `risk_limits.json` (`tests/test_config_parsing.py:1-40`), the dry-run exchange client remains covered (`tests/test_exchange_dry_run.py:1-89`), and screener tier caps plus router metrics readers have targeted regression tests (`tests/test_screener_tier_caps.py:1-116`, `tests/test_router_metrics_reader.py:1-36`).

## V6.0 INPUT GAPS
- **Expectancy models (time-of-day & trade expectancy):** `execution/intel/expectancy_map.py:7-78` expects `realized_pnl` and `notional` per router event, but `route_intent()` never supplies that data (`execution/order_router.py:620-682`). We need to emit per-fill realized PnL from `_confirm_order_fill()` (`execution/executor_live.py:2250-2350`) into order metrics so hourly expectancy stops returning `None` and downstream dashboards see time-of-day edge.
- **Symbol scoring (Sharpe / fee drag / slippage regime / router KPIs):** While `execution/utils/metrics.py:195-239` exposes helpers, nothing publishes those readings because `_maybe_publish_execution_health()` is stubbed (`execution/executor_live.py:98-105`). Health payloads should include rolling Sharpe, fees, slip quartiles, RouterPolicy quality, and maker offsets so symbol scores can drive registry weighting.
- **Router auto-tuning:** Policy snapshots are attached to `router_ctx` but never logged, and events lack `is_maker_final`, `started_maker`, or `used_fallback`. Without those fields, `router_effectiveness_7d()` cannot feed adaptive offsets or maker/taker toggles. Router metrics need to record the RouterPolicy decision, the actual route taken, fallback ratios, and any auto-cancel loops so v6.0’s router adjustments have data to learn from.
- **Feedback allocator hooks:** The executor already tracks vetoes via `_persist_veto()` and fills via `_append_order_metrics`, but there is no feed that ties `size_model` suggestions, risk veto stacks, and realized PnL together. We need a per-trade record (symbol, tier, suggested gross, clamped gross, veto reasons, final fill, fees) so feedback allocators can reweight strategies and NAV limits in real time.

## RECOMMENDED PATCH BATCHES
- **Batch A – Risk/screener contract & config cleanup:** Pass `open_positions_count`, `tier_name`, and `current_tier_gross_notional` from `_send_order()` into `check_order()` (`execution/executor_live.py:1717-1729`) so concurrency/tier limits finally apply. Align `risk_limits.json` and `strategy_config.json` on `min_notional` and concurrency values, rename `trade_gt_10pct_equity` + expose orderbook thresholds in config, and move `SYMBOL_NOTIONAL_CAP`/`SYM_DD_CAP_PCT` into `config/risk_limits.json` so screener/executor share the same knobs.
- **Batch B – Router & telemetry exposure:** Implement the no-op publisher hooks (`execution/executor_live.py:94-107`), enrich `router_metrics` with maker/taker/fallback flags plus RouterPolicy metadata (`execution/order_router.py:620-682`), and push those events to the configured telemetry sink so `router_effectiveness_7d()` and `execution/utils/execution_health.py:1-90` report accurate KPIs.
- **Batch C – Expectancy + scoring hooks:** Capture realized PnL and per-intent sizing context when fills settle (`execution/executor_live.py:2250-2350`) so `execution/intel/expectancy_map.py:7-78` and `execution/utils/metrics.hourly_expectancy()` can populate expectancy heatmaps. Publish those stats (and Sharpe/fee/slip readings) through `_maybe_publish_execution_intel()` so the feedback allocator and router auto-tuning layers have structured inputs for v6.0.
