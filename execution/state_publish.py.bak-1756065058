#!/usr/bin/env python3
from __future__ import annotations
import os, time, json, hashlib, pathlib
ROOT_DIR = pathlib.Path(__file__).resolve().parents[1]
from typing import List, Dict, Any

# .env best effort
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv()
except Exception:
    pass

ENV = os.getenv("ENV","prod")
def _ensure_keys():
    # if keys are still missing, parse .env lines
    if os.getenv('BINANCE_API_KEY') and os.getenv('BINANCE_API_SECRET'):
        return
    env_path = ROOT_DIR / '.env'
    if not env_path.exists():
        return
    for ln in env_path.read_text().splitlines():
        ln=ln.strip()
        if not ln or ln.startswith('#') or '=' not in ln: continue
        k,v = ln.split('=',1)
        os.environ.setdefault(k.strip(), v.strip())

FS_ROOT = f"hedge/{ENV}/state"
CREDS_PATH = os.getenv("GOOGLE_APPLICATION_CREDENTIALS") or str((ROOT_DIR / 'config/firebase_creds.json'))

_ensure_keys()

def _fs_client():
    from google.cloud import firestore  # type: ignore
    # If a creds file is present, use it; otherwise default ADC
    if os.path.exists(CREDS_PATH):
        from google.oauth2 import service_account  # type: ignore
        info = json.load(open(CREDS_PATH))
        creds = service_account.Credentials.from_service_account_file(CREDS_PATH)
        return firestore.Client(project=info.get("project_id"), credentials=creds)
    return firestore.Client()

def normalize_positions(raw: List[Dict[str,Any]]) -> List[Dict[str,Any]]:
    # Load universe if present
    universe = None
    try:
        u = json.load(open(str((ROOT_DIR / 'config/pairs_universe.json'))))
        universe = set(u.get('symbols', []))
    except Exception:
        pass
    rows: List[Dict[str,Any]] = []
    for p in raw or []:
        try:
            sym = p.get("symbol")
            if universe and sym not in universe:
                continue
            qty = float(p.get("qty", p.get("positionAmt", 0)) or 0)
            if qty == 0.0:
                continue
            rows.append({
                "symbol": sym,
                "positionSide": p.get("positionSide") or "BOTH",
                "qty": qty,
                "entryPrice": float(p.get("entryPrice") or 0),
                "leverage": float(p.get("leverage") or 0),
                "uPnl": float(p.get("unRealizedProfit", p.get("unrealized", 0)) or 0),
            })
        except Exception:
            pass
    return rows

def publish_positions(rows: List[Dict[str,Any]]) -> None:
    cli = _fs_client()
    cli.document(f"{FS_ROOT}/positions").set({
        "rows": rows,
        "updated": time.time(),
    }, merge=True)

class StatePublisher:
    def __init__(self, interval_s: int = 60):
        self.interval_s = interval_s
        self._h = None
        self._t = 0.0
    def maybe_publish_positions(self, rows: List[Dict[str,Any]]) -> None:
        body = json.dumps(rows, sort_keys=True, default=str).encode()
        h = hashlib.sha256(body).hexdigest()
        now = time.time()
        if h != self._h or (now - self._t) >= self.interval_s:
            publish_positions(rows)
            self._h = h
            self._t = now

if __name__ == "__main__":
    # preflight: make sure this process sees keys & can sign
    from execution.exchange_utils import is_testnet, _req
    try:
        _ = _req("GET", "/fapi/v1/time")
        _ = _req("GET", "/fapi/v2/balance", signed=True)
        preflight_ok = True
    except Exception as e:
        print("preflight_error:", e)
        preflight_ok = False
    if not preflight_ok:
        raise SystemExit(1)

    # one-shot CLI: sync current positions to Firestore
    from execution.exchange_utils import get_positions
    raw = get_positions()
    rows = normalize_positions(raw)
    publish_positions(rows)
    print("published positions:", len(rows))
