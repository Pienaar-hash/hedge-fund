#!/usr/bin/env python3
"""
Pure SL/TP rules for the hedge bot.

Interfaces:
- compute_sl_tp(entry_px, side, atr, atr_mult, fixed_sl_pct, fixed_tp_pct, trail=None)
- should_exit(prices, entry_px, side, sl_px, tp_px, max_bars, trail=None)

Notes:
- `side` is "LONG" or "SHORT".
- `atr` is a *fraction* of price (e.g., 0.0025 ~ 0.25%), matching your screener.
- If ATR inputs are provided, offsets use: max(fixed_pct, atr * atr_mult).
- `trail` is optional dict, e.g. {"width_pct": 0.006} for a 0.6% trailing width.
"""

from typing import Iterable, Optional, Tuple, Dict

def _pct_to_abs(px: float, pct: float) -> float:
    return px * float(pct)

def compute_sl_tp(
    entry_px: float,
    side: str,
    atr: float = 0.0,
    atr_mult: float = 0.0,
    fixed_sl_pct: float = 0.0,
    fixed_tp_pct: float = 0.0,
    trail: Optional[Dict] = None,
) -> Tuple[float, float]:
    """
    Returns (sl_px, tp_px). No rounding is applied here; executor can round to tickSize.
    """
    side = side.upper()
    # pct inputs can be "percent" (e.g. 0.6) or "fraction" (0.006). Accept both.
    def _norm_pct(x: float) -> float:
        # treat >= 1.0 as percent, else fraction
        return (x / 100.0) if x >= 1.0 else x

    sl_pct = _norm_pct(fixed_sl_pct)
    tp_pct = _norm_pct(fixed_tp_pct)

    atr = float(atr or 0.0)
    atr_mult = float(atr_mult or 0.0)
    if atr > 0.0 and atr_mult > 0.0:
        sl_pct = max(sl_pct, atr * atr_mult)
        tp_pct = max(tp_pct, atr * atr_mult)

    if side == "LONG":
        sl_px = entry_px * (1.0 - sl_pct) if sl_pct > 0 else entry_px
        tp_px = entry_px * (1.0 + tp_pct) if tp_pct > 0 else entry_px
    elif side == "SHORT":
        sl_px = entry_px * (1.0 + sl_pct) if sl_pct > 0 else entry_px
        tp_px = entry_px * (1.0 - tp_pct) if tp_pct > 0 else entry_px
    else:
        raise ValueError("side must be 'LONG' or 'SHORT'")

    return float(sl_px), float(tp_px)

def should_exit(
    prices: Iterable[float],
    entry_px: float,
    side: str,
    sl_px: float,
    tp_px: float,
    max_bars: int,
    trail: Optional[Dict] = None,
) -> bool:
    """
    Evaluates exit conditions on a chronological sequence of prices.
    Returns True if any exit condition (TP/SL/TRAIL/TIME) is satisfied.
    """
    side = side.upper()
    it = list(float(x) for x in prices)
    if not it:
        return False

    last = it[-1]

    # Hard TP/SL
    if side == "LONG":
        if last >= tp_px:  # take profit
            return True
        if last <= sl_px:  # stop loss
            return True
    elif side == "SHORT":
        if last <= tp_px:
            return True
        if last >= sl_px:
            return True
    else:
        raise ValueError("side must be 'LONG' or 'SHORT'")

    # Trailing stop (optional): width_pct relative to last favorable extreme
    if trail and float(trail.get("width_pct", 0)) > 0:
        w = float(trail["width_pct"])
        if side == "LONG":
            peak = max(it)
            trail_px = peak * (1.0 - w)
            if last <= trail_px:
                return True
        else:  # SHORT
            trough = min(it)
            trail_px = trough * (1.0 + w)
            if last >= trail_px:
                return True

    # Time stop
    if max_bars and len(it) >= int(max_bars):
        return True

    return False
