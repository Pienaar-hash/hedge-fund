# execution/executor_live.py â€” Phase 2 (atomic NAV, futures sizing, ATR exits, config knobs)

import os
import json
import time
from datetime import datetime, timezone
from typing import Dict, List, Set, Tuple, Optional
from collections import deque

from execution.exchange_utils import (
    get_balances,
    get_price,            # returns float price (futures prefers mark price)
    place_market_order,   # entry/exit market orders
    get_positions,        # live futures positions snapshot for Firestore
)
from execution.signal_screener import generate_signals_from_config

# -----------------------------------------------------------------------------
# Files (override via env in Supervisor)
NAV_LOG = os.getenv("NAV_LOG", "nav_log.json")
PEAK_STATE = os.getenv("PEAK_STATE", "peak_state.json")
STATE_FILE = os.getenv("STATE_FILE", "synced_state.json")
CFG_FILE = os.getenv("CFG_FILE", "config/strategy_config.json")
NAV_MAX_POINTS = int(os.getenv("NAV_MAX_POINTS", "1000"))
# -----------------------------------------------------------------------------

# ========================= Atomic I/O & NAV helpers ==========================

def _write_json_atomic(path: str, data) -> None:
    tmp = f"{path}.tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, separators=(",", ":"), ensure_ascii=False)
    os.replace(tmp, path)

def _read_json_list(path: str) -> List[dict]:
    try:
        with open(path, "r", encoding="utf-8") as f:
            d = json.load(f)
        return d if isinstance(d, list) else []
    except Exception:
        return []

def _read_json_dict(path: str) -> Dict:
    try:
        with open(path, "r", encoding="utf-8") as f:
            d = json.load(f)
        return d if isinstance(d, dict) else {}
    except Exception:
        return {}

def _utc_ts() -> int:
    return int(datetime.now(timezone.utc).timestamp())

def _update_peak(peak_state: dict, equity_now: float) -> dict:
    peak = float(peak_state.get("peak_equity", 0.0))
    if equity_now > peak:
        peak_state["peak_equity"] = equity_now
        peak_state["peak_ts"] = _utc_ts()
    return peak_state

def _drawdown_pct(equity: float, peak: float) -> float:
    if peak <= 0:
        return -1.0
    return (equity / peak) - 1.0

def append_nav_point_atomic(realized: float, unrealized: float, balance: float, equity: float) -> dict:
    rows = _read_json_list(NAV_LOG)
    ts = datetime.now(timezone.utc).isoformat()
    peak_state = _read_json_dict(PEAK_STATE)
    peak_state = _update_peak(peak_state, float(equity))
    dd_pct = _drawdown_pct(float(equity), float(peak_state.get("peak_equity", 0.0)))

    point = {
        "timestamp": ts,
        "realized": float(realized),
        "unrealized": float(unrealized),
        "balance": float(balance),
        "equity": float(equity),
        "drawdown_pct": float(dd_pct),
    }
    rows.append(point)
    if len(rows) > NAV_MAX_POINTS:
        rows = rows[-NAV_MAX_POINTS:]
    _write_json_atomic(NAV_LOG, rows)
    _write_json_atomic(PEAK_STATE, peak_state)
    return point

# =============================== ATR cache ==================================

def _px(symbol: str) -> float:
    """Robust price fetch that accepts either float or dict from get_price()."""
    try:
        p = get_price(symbol)
        if isinstance(p, dict):
            v = p.get("price") or p.get("markPrice") or p.get("lastPrice")
            return float(v or 0.0)
        return float(p or 0.0)
    except Exception:
        return 0.0

class _AtrCache:
    """Lightweight ATR proxy using just last prices per symbol.
    Approximates H/L over a sliding window; Wilder smoothing of TR.
    """
    def __init__(self, period: int = 14, window: Optional[int] = None):
        self.p = int(period)
        self.w = int(window or max(3, period))
        self.buf: Dict[str, deque] = {}
        self.prev_close: Dict[str, float] = {}
        self.atr: Dict[str, float] = {}

    def update(self, symbol: str, price: float, period: Optional[int] = None) -> Optional[float]:
        if price is None or price <= 0:
            return self.atr.get(symbol)
        p = int(period or self.p)
        d = self.buf.get(symbol)
        if d is None:
            d = deque(maxlen=self.w)
            self.buf[symbol] = d
        d.append(float(price))
        prev = self.prev_close.get(symbol)
        high = max(d) if d else price
        low  = min(d) if d else price
        tr = (high - low) if prev is None else max(high - low, abs(high - prev), abs(low - prev))
        a_prev = self.atr.get(symbol)
        a = tr if a_prev is None else (a_prev * (p - 1) + tr) / p
        self.atr[symbol] = a
        self.prev_close[symbol] = float(price)
        return a

_ATR = _AtrCache(period=14)

# ============================ Exit decision logic ============================

def _position_qty(capital_usd: float, price: float, leverage: float = 1.0, min_notional: float = 5.0) -> float:
    notional = max(float(capital_usd) * float(leverage), float(min_notional))
    if price <= 0:
        return 0.0
    return notional / float(price)

def should_exit(state: dict, price: float, atr_value: Optional[float], cfg_exit: dict) -> Tuple[Optional[str], Optional[float]]:
    """Return (reason, trigger_price) or (None, None)."""
    # Fixed TP
    tp_pct = float(cfg_exit.get("tp_pct", 0.0)) / 100.0
    if tp_pct > 0:
        ep = float(state.get("entry_price", 0.0))
        if state.get("side") == "LONG" and price >= ep * (1.0 + tp_pct):
            return ("TP", None)
        if state.get("side") == "SHORT" and price <= ep * (1.0 - tp_pct):
            return ("TP", None)

    # ATR trailing
    p = int(cfg_exit.get("atr_period", 14))
    m = float(cfg_exit.get("atr_multiple", 2.0))
    if atr_value and p > 0 and m > 0:
        if state.get("side") == "LONG":
            trail = price - m * atr_value
            state["trail_stop"] = max(float(state.get("trail_stop", 0.0)), trail)
            if price <= state["trail_stop"]:
                return ("ATR_TRAIL", state["trail_stop"])
        elif state.get("side") == "SHORT":
            trail = price + m * atr_value
            cur = float("inf") if state.get("trail_stop") is None else float(state.get("trail_stop", float("inf")))
            state["trail_stop"] = min(cur, trail)
            if price >= state["trail_stop"]:
                return ("ATR_TRAIL", state["trail_stop"])

    # Time stop
    max_bars = int(cfg_exit.get("max_bars", 0))
    if max_bars > 0 and int(state.get("bars_held", 0)) >= max_bars:
        return ("TIME", None)

    return (None, None)

# =============================== Positions I/O ===============================

def _positions_from_state() -> Dict[str, dict]:
    raw = _read_json_dict(STATE_FILE)
    items = raw.get("items") if isinstance(raw, dict) else raw
    out: Dict[str, dict] = {}
    if isinstance(items, list):
        for it in items:
            sym = (it or {}).get("symbol")
            if sym:
                out[sym] = {k: v for k, v in (it or {}).items() if k != "symbol"}
    elif isinstance(items, dict):
        out = items
    return out

def _save_positions_state(positions: Dict[str, dict]) -> None:
    items = [{"symbol": s, **(positions[s] or {})} for s in sorted(positions.keys())]
    _write_json_atomic(STATE_FILE, {"items": items})

# =============================== Live position snapshot ==============================

def _to_float(x, default=0.0):
    try:
        if isinstance(x, dict) and "price" in x:
            return float(x["price"])  # defensive: accept {price: ...}
        return float(x)
    except Exception:
        return default

def snapshot_positions_to_synced_state() -> int:
    """Read live exchange positions and publish synced_state.json for Firestore.
    Uses exchange_utils.get_positions() wrapper; computes mark and unrealized PnL.
    """
    try:
        pos = get_positions() or []
        items = []
        now = datetime.now(timezone.utc).isoformat()
        for p in pos:
            sym = (p or {}).get("symbol")
            if not sym:
                continue
            qty = _to_float((p or {}).get("qty", (p or {}).get("positionAmt", 0.0)))
            if abs(qty) <= 0.0:
                continue
            entry = _to_float((p or {}).get("entry_price", (p or {}).get("entryPrice", 0.0)))
            mark = _px(sym)
            unreal = (mark - entry) * qty
            notional = abs(qty) * mark
            lev = int(_to_float((p or {}).get("leverage", 1)))
            items.append({
                "symbol": sym,
                "qty": qty,
                "entry_price": entry,
                "mark": mark,
                "unrealized_pnl": unreal,
                "notional": notional,
                "leverage": lev,
                "side": "LONG" if qty >= 0 else "SHORT",
                "updated_at": now,
            })
        _write_json_atomic(STATE_FILE, {"items": items, "updated_at": now})
        print(f"[positions] published {len(items)} items", flush=True)
        return len(items)
    except Exception as e:
        print(f"[positions] snapshot failed: {e}", flush=True)
        return 0

# ============================== Price refresh ===============================

def refresh_positions_latest_prices(positions: Dict[str, dict]) -> None:
    for sym, pos in positions.items():
        try:
            last = _px(sym)
            pos["latest_price"] = last
            _ATR.update(sym, last)  # feed ATR cache
            qty = float(pos.get("qty", 0.0))
            entry = float(pos.get("entry", 0.0))
            pos["pnl"] = (pos["latest_price"] - entry) * qty
        except Exception:
            pass

# ============================== Equity components ===========================

def _equity_components(balances: dict, positions: Dict[str, dict], allowed_assets: Set[str]) -> Tuple[float, float, float]:
    # Balance via USDT + priced allowed assets
    balance = float(balances.get("USDT", 0.0))
    for asset, qty in (balances or {}).items():
        if asset == "USDT" or asset not in allowed_assets:
            continue
        sym = f"{asset}USDT"
        px = _px(sym)
        if px > 0:
            balance += float(qty) * px
    # Unrealized from open positions
    unreal = 0.0
    for sym, pos in positions.items():
        qty = float(pos.get("qty", 0.0))
        if qty == 0.0:
            continue
        entry = float(pos.get("entry", 0.0))
        last = float(pos.get("latest_price", 0.0)) or _px(sym)
        unreal += (last - entry) * qty
    equity = balance + unreal
    return balance, unreal, equity

# ============================ Config loader & validator ======================
REQUIRED_GLOBAL_KEYS = {"use_futures", "min_notional", "heartbeat_minutes", "whitelist"}
REQUIRED_STRAT_KEYS = {"symbol", "capital_per_trade", "leverage", "kelly_fraction", "entry", "exit"}
REQUIRED_ENTRY_KEYS = {"zscore_min", "rsi_band"}
REQUIRED_EXIT_KEYS = {"tp_pct", "atr_period", "atr_multiple", "max_bars"}

def _dict_strats_from_config(cfg: dict) -> dict:
    s = cfg.get("strategies")
    if isinstance(s, dict):
        return s
    out = {}
    if isinstance(s, list):
        for item in s:
            name = (item or {}).get("name")
            params = (item or {}).get("params", {})
            if name:
                out[name] = {
                    "symbol": params.get("symbol"),
                    "capital_per_trade": params.get("capital_per_trade"),
                    "leverage": params.get("leverage"),
                    "kelly_fraction": params.get("kelly_fraction"),
                    "entry": {
                        "zscore_min": (params.get("zscore_min") or (params.get("entry") or {}).get("zscore_min")),
                        "rsi_band": (params.get("rsi_band") or (params.get("entry") or {}).get("rsi_band")),
                    },
                    "exit": (params.get("exit") or {}),
                    "min_notional": params.get("min_notional_usdt"),
                }
    return out

def validate_config(cfg: dict) -> None:
    warnings = []
    g = cfg.get("global", {})
    missing_global = [k for k in REQUIRED_GLOBAL_KEYS if k not in g]
    if missing_global:
        warnings.append(f"global missing keys: {missing_global}")
    if "whitelist" in g and not isinstance(g.get("whitelist"), list):
        warnings.append("global.whitelist should be a list of symbols (e.g., BTCUSDT)")
    if "use_futures" in g and not isinstance(g.get("use_futures"), bool):
        warnings.append("global.use_futures should be a boolean")
    strats = _dict_strats_from_config(cfg)
    if not strats:
        warnings.append("no strategies defined")
    else:
        wl = set(g.get("whitelist") or [])
        for name, st in strats.items():
            missing = [k for k in REQUIRED_STRAT_KEYS if k not in (st or {})]
            if missing:
                warnings.append(f"strategy '{name}' missing keys: {missing}")
            sym = (st or {}).get("symbol")
            if sym and not str(sym).endswith("USDT"):
                warnings.append(f"strategy '{name}' symbol '{sym}' should end with USDT")
            if sym and wl and sym not in wl:
                warnings.append(f"strategy '{name}' symbol '{sym}' not present in global.whitelist")
            ent = (st or {}).get("entry") or {}
            exi = (st or {}).get("exit") or {}
            for k in REQUIRED_ENTRY_KEYS:
                if k not in ent:
                    warnings.append(f"strategy '{name}'.entry missing '{k}'")
            for k in REQUIRED_EXIT_KEYS:
                if k not in exi:
                    warnings.append(f"strategy '{name}'.exit missing '{k}'")
    if warnings:
        print("[config][WARN] " + " | ".join(warnings), flush=True)
    else:
        print("[config] OK", flush=True)

def load_config() -> dict:
    if not os.path.exists(CFG_FILE):
        return {
            "global": {
                "use_futures": False,
                "min_notional": 10.0,
                "heartbeat_minutes": 1,
                "whitelist": ["BTCUSDT", "ETHUSDT"],
            },
            "strategies": {}
        }
    with open(CFG_FILE, "r", encoding="utf-8") as f:
        cfg = json.load(f)
    validate_config(cfg)
    return cfg

def build_asset_whitelist(cfg: dict) -> Set[str]:
    wl = (cfg.get("global", {}) or {}).get("whitelist") or []
    allowed = {"USDT"}
    for sym in wl:
        if isinstance(sym, str) and sym.upper().endswith("USDT"):
            allowed.add(sym[:-4])  # base asset
    return allowed

def get_capital_for_strategy(config: dict, strategy_name: str, usdt_balance: float) -> float:
    fallback = max(10.0, min(usdt_balance * 0.01, 500.0))
    st = _dict_strats_from_config(config).get(strategy_name) or {}
    try:
        cap = st.get("capital_per_trade")
        return float(cap) if cap is not None else fallback
    except Exception:
        return fallback

def get_trade_knobs(config: dict, strategy_name: str) -> Tuple[float, float]:
    g = config.get("global", {}) or {}
    global_min = float(g.get("min_notional", 10.0))
    sell_close_pct_default = float((config.get("trade_defaults", {}) or {}).get("sell_close_pct", 1.0))
    st = _dict_strats_from_config(config).get(strategy_name) or {}
    per_min = st.get("min_notional")
    try:
        per_min = float(per_min) if per_min is not None else global_min
    except Exception:
        per_min = global_min
    sell_close_pct = float((st.get("exit") or {}).get("sell_close_pct", sell_close_pct_default))
    return sell_close_pct, per_min

# ================================ Main tick =================================

def executor_tick(config: dict, allowed_assets: Set[str]) -> None:
    g = config.get("global", {}) or {}
    strats = _dict_strats_from_config(config)

    # Load state
    positions = _positions_from_state()

    # 1) Balances & price refresh
    balances = get_balances() or {}
    balance_keys = list(balances.keys()) if isinstance(balances, dict) else balances
    print("[dbg] got balances:", balance_keys, flush=True)
    refresh_positions_latest_prices(positions)

    # 2) Equity components
    balance, unreal, equity = _equity_components(balances, positions, allowed_assets)

    # 3) Persist NAV (atomic + peak + drawdown)
    append_nav_point_atomic(realized=0.0, unrealized=unreal, balance=balance, equity=equity)

    # 4) Generate signals
    signals = list(generate_signals_from_config(config) or [])
    if signals:
        print(f"[dbg] generated signals: {len(signals)}", flush=True)

    # 5) Per-signal entries
    for sig in signals:
        try:
            sym = sig.get('symbol')
            strat_key = sig.get('strategy') or sig.get('strategy_name')
            if not sym or not strat_key:
                continue
            st_cfg = strats.get(strat_key) or {}
            # Whitelist
            wl = set(g.get("whitelist") or [])
            if wl and sym not in wl:
                continue
            # Entry guards
            entry_cfg = (st_cfg.get("entry") or {})
            zmin = float(entry_cfg.get("zscore_min", 0.0))
            rsi_band = entry_cfg.get("rsi_band") or [0, 100]
            z = float(sig.get('z_score') or sig.get('z') or 0.0)
            rsi = float(sig.get('rsi') or 50.0)
            if z < zmin:
                continue
            if not (float(rsi_band[0]) <= rsi <= float(rsi_band[1])):
                continue
            if (sig.get('signal') or '').upper() != 'BUY':
                continue
            # Sizing
            cap = float(st_cfg.get("capital_per_trade", 0.0))
            lev = float(st_cfg.get("leverage", 1.0))
            mn  = float(st_cfg.get("min_notional", g.get("min_notional", 5.0)))
            px = _px(sym)
            qty = _position_qty(capital_usd=cap, price=px, leverage=lev, min_notional=mn)
            if qty <= 0.0:
                continue
            # Place order
            res = place_market_order(sym, 'BUY', qty)
            if not res or not res.get('ok'):
                print(f"[trade][ERR] entry {strat_key} {sym} qty={qty}: {(res or {}).get('_error')}", flush=True)
                continue
            # Update local position
            pos = positions.get(sym) or {}
            pos.update({
                "in_position": True,
                "qty": pos.get("qty", 0.0) + qty,
                "entry": pos.get("entry", px),
                "entry_price": pos.get("entry_price", px),
                "latest_price": px,
                "strategy": strat_key,
                "side": "LONG",
                "bars_held": int(pos.get("bars_held", 0)),
            })
            positions[sym] = pos
            print(f"[trade] BUY {sym} qty={qty:.6f} px={px} strat={strat_key}", flush=True)
        except Exception as e:
            print(f"[trade][ERR] {e}", flush=True)

    # 6) Exit checks
    for sym, pos in list(positions.items()):
        try:
            if not pos.get("in_position") or float(pos.get("qty", 0.0)) <= 0.0:
                continue
            st_key = pos.get("strategy")
            st_cfg = strats.get(st_key) or {}
            ex_cfg = (st_cfg.get("exit") or {})
            px = _px(sym)
            atr_period = int((ex_cfg or {}).get("atr_period", 14))
            atr_val = _ATR.update(sym, px, period=atr_period)
            pos.setdefault("bars_held", 0)
            reason, trigger = should_exit(pos, price=px, atr_value=atr_val, cfg_exit=ex_cfg)
            if reason:
                qty = float(pos.get("qty", 0.0))
                if qty <= 0:
                    continue
                res = place_market_order(sym, 'SELL', qty)
                if not res or not res.get('ok'):
                    print(f"[trade][ERR] exit {st_key} {sym}: {(res or {}).get('_error')}", flush=True)
                    continue
                # Reset position
                pos.update({
                    "in_position": False,
                    "qty": 0.0,
                    "latest_price": px,
                    "bars_held": 0,
                })
                print(f"[exit:{reason}] SELL {sym} qty={qty:.6f} px={px} strat={st_key}", flush=True)
            else:
                pos["bars_held"] = int(pos.get("bars_held", 0)) + 1
        except Exception as e:
            print(f"[exit][ERR] {sym}: {e}", flush=True)

    # 7) Persist positions for sync_state
    if positions:
        _save_positions_state(positions)
    else:
        # If executor isn't tracking any local positions, publish live exchange snapshot
        snapshot_positions_to_synced_state()

# ================================== Main ====================================

def main():
    print("ðŸš€ Executor Live (Phase 2)", flush=True)
    config = load_config()

    # Global knobs â†’ env
    g = config.get("global", {}) or {}
    cfg_use_futures = bool(g.get("use_futures", False))
    os.environ["USE_FUTURES"] = "1" if cfg_use_futures else "0"

    # Poll interval from heartbeat
    poll = int(max(5, int(g.get("heartbeat_minutes", 1)) * 60))

    # Whitelist â†’ base assets for equity pricing
    allowed_assets = build_asset_whitelist(config)

    # Log effective mode
    use_futures = os.getenv("USE_FUTURES", "0").lower() in ("1", "true", "yes")
    print(f"[cfg] use_futures={use_futures} poll={poll}s whitelist={sorted(list(allowed_assets))}", flush=True)

    one_shot = os.getenv("ONE_SHOT", "0").lower() in ("1", "true", "yes")
    if one_shot:
        executor_tick(config, allowed_assets)
        return

    while True:
        t0 = time.time()
        try:
            executor_tick(config, allowed_assets)
        except Exception as e:
            print(f"[loop][ERR] {e}", flush=True)
        dt = time.time() - t0
        time.sleep(max(1.0, poll - dt))


if __name__ == "__main__":
    main()
