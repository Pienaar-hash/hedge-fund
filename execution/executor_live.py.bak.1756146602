#!/usr/bin/env python3
from __future__ import annotations

import os, time, json, logging
from typing import Any, Dict, Iterable

# Optional .env
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv()
except Exception:
    pass

LOG = logging.getLogger("exutil")
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s [exutil] %(message)s",
)

# --- Exchange utils ---
from execution.exchange_utils import (
    is_testnet, get_balances, get_positions, _is_dual_side, place_market_order_sized,
)

# --- Screener (best effort import) ---
try:
    from execution.signal_screener import generate_signals_from_config  # type: ignore
except Exception:
    generate_signals_from_config = None  # type: ignore

# --- Firestore publisher handle (present in some revs) ---
try:
    from execution.state_publish import StatePublisher  # type: ignore
except Exception:
    class StatePublisher:  # type: ignore
        def __init__(self, interval_s: int = 60): self.interval_s = interval_s

_PUB = StatePublisher(interval_s=int(os.getenv("FS_PUB_INTERVAL", "60")))

# --- runtime knobs ---
SLEEP       = int(os.getenv("LOOP_SLEEP", "60"))
MAX_LOOPS   = int(os.getenv("MAX_LOOPS", "0") or 0)
DRY_RUN     = os.getenv("DRY_RUN", "0").lower() in ("1","true","yes")
INTENT_TEST = os.getenv("INTENT_TEST", "0").lower() in ("1","true","yes")

# ---------------- helpers ----------------

def _account_snapshot() -> None:
    try:
        bals = get_balances() or []
        assets = sorted({b.get("asset","?") for b in bals})
        pos = [p for p in get_positions() if float(p.get("qty", p.get("positionAmt", 0)) or 0) != 0]
        LOG.info("[executor] account OK — futures=%s testnet=%s dry_run=%s balances: %s positions: %d",
                 True, is_testnet(), DRY_RUN, assets, len(pos))
    except Exception as e:
        LOG.exception("[executor] preflight_error: %s", e)

def _send_order(intent: Dict[str, Any]) -> None:
    symbol = intent["symbol"]
    sig = str(intent.get("signal","")).upper()
    side = "BUY" if sig == "BUY" else "SELL"
    pos_side = intent.get("positionSide") or ("LONG" if side=="BUY" else "SHORT")
    cap = float(intent.get("capital_per_trade", 0) or 0)
    lev = float(intent.get("leverage", 1) or 1)
    notional = cap * lev
    reduce_only = bool(intent.get("reduceOnly", False))

    LOG.info("[executor] INTENT symbol=%s side=%s ps=%s cap=%.4f lev=%.2f reduceOnly=%s",
             symbol, side, pos_side, cap, lev, reduce_only)

    if DRY_RUN:
        LOG.info("[executor] DRY_RUN — skipping SEND_ORDER")
        return

    LOG.info("[executor] SEND_ORDER %s %s", symbol, side)
    resp = place_market_order_sized(
        symbol=symbol, side=side, notional=notional, leverage=lev,
        position_side=pos_side, reduce_only=reduce_only
    )
    oid = resp.get("orderId")
    avg = resp.get("avgPrice","0.00")
    qty = resp.get("executedQty", resp.get("origQty","0"))
    st  = resp.get("status")
    LOG.info("[executor] ORDER_REQ 200 id=%s avgPrice=%s qty=%s", oid, avg, qty)
    if st == "FILLED":
        LOG.info("[executor] ORDER_FILL id=%s status=%s avgPrice=%s qty=%s", oid, st, avg, qty)

def _pub_tick() -> None:
    """
    Try publisher methods if present; otherwise publish NAV+positions inline.
    """
    # Try common method names on StatePublisher
    for meth in ("tick","run_once","step","publish","update"):
        m = getattr(_PUB, meth, None)
        if callable(m):
            try:
                m()
                return
            except Exception as e:
                LOG.error("[executor] publisher.%s error: %s", meth, e)

    # Inline minimal publish (NAV + positions)
    try:
        # NAV
        nav_val = None
        try:
            from execution.state_publish import compute_nav  # type: ignore
            nav_val = float(compute_nav())
        except Exception as e:
            LOG.error("[executor] compute_nav not available: %s", e)
            try:
                from execution.exchange_utils import get_account  # type: ignore
                acc = get_account()
                nav_val = float(
                    acc.get("totalMarginBalance") or
                    (float(acc.get("totalWalletBalance",0) or 0) +
                     float(acc.get("totalUnrealizedProfit",0) or 0))
                )
            except Exception as ee:
                LOG.error("[executor] account NAV error: %s", ee)

        # Positions -> normalized rows
        rows: Iterable[Dict[str, Any]]
        try:
            r = get_positions()
        except Exception as e:
            LOG.error("[executor] get_positions error: %s", e)
            r = []
        rows = []
        for p in r:
            try:
                rows.append({
                    "symbol": p.get("symbol"),
                    "positionSide": p.get("positionSide","BOTH"),
                    "qty": float(p.get("qty", p.get("positionAmt", 0)) or 0.0),
                    "entryPrice": float(p.get("entryPrice") or 0.0),
                    "unrealized": float(p.get("unRealizedProfit", p.get("unrealized", 0)) or 0.0),
                    "leverage": float(p.get("leverage") or 0.0),
                })
            except Exception:
                continue

        # Firestore write
        try:
            from google.cloud import firestore  # type: ignore
            ENV = os.getenv("ENV","prod")
            db = firestore.Client()

            # NAV series (append)
            if nav_val is not None:
                doc_nav = db.document(f"hedge/{ENV}/state/nav")
                snap = doc_nav.get()
                series = []
                if snap.exists:
                    d = snap.to_dict() or {}
                    series = d.get("series") or d.get("rows") or []
                series.append({"t": time.time(), "nav": float(nav_val)})
                series = series[-20000:]
                doc_nav.set({"series": series}, merge=False)

            # Positions table
            db.document(f"hedge/{ENV}/state/positions").set({"rows": list(rows)}, merge=False)
        except Exception as e:
            LOG.error("[executor] Firestore publish error: %s", e)
    except Exception as e:
        LOG.error("[executor] publisher fallback error: %s", e)

def _loop_once(i: int) -> None:
    _account_snapshot()

    if INTENT_TEST:
        intent = {
            "symbol":"BTCUSDT","signal":"BUY","capital_per_trade":120.0,
            "leverage":1, "positionSide":"LONG", "reduceOnly":False
        }
        LOG.info("[screener->executor] %s", intent)
        _send_order(intent)
    else:
        if generate_signals_from_config:
            try:
                for intent in (generate_signals_from_config() or []):
                    LOG.info("[screener->executor] %s", intent)
                    _send_order(intent)
            except Exception as e:
                LOG.error("[screener] error: %s", e)
        else:
            LOG.error("[screener] missing signal generator")

    _pub_tick()

def main() -> None:
    try:
        if not _is_dual_side():
            LOG.warning("[executor] WARNING — account not in hedge (dualSide) mode")
    except Exception as e:
        LOG.error("[executor] dualSide check failed: %s", e)

    i = 0
    while True:
        _loop_once(i)
        i += 1
        if MAX_LOOPS and i >= MAX_LOOPS:
            LOG.info("[executor] MAX_LOOPS reached — exiting.")
            break
        time.sleep(SLEEP)

if __name__ == "__main__":
    main()
