v5.10.2 = Adaptive Sizing Layer, built on the intel weâ€™ve just wired in.

Weâ€™ll keep this very controlled: bounded multipliers, deterministic logic, and fully test-covered.

ðŸŽ¯ v5.10.2 Goal

Use the symbol intelligence (from compute_symbol_score) to adjust final order size:

High-quality symbols â†’ slightly higher size.

Mediocre â†’ neutral.

Poor / unstable â†’ lower size.

Everything:

stays within a hard clamp range (e.g. 0.25xâ€“2.0x)

plays nicely with your existing ATR/Sharpe sizing stack

is easily reversible and observable.

ðŸ§± High-Level Design

We already have:

execution.intel.symbol_score.compute_symbol_score(symbol)

execution.intel.symbol_score.score_to_size_factor(score)

execution/signal_generator.py â†’ size_for(symbol, gross_target)

execution/position_sizing.py (ATR / inverse-vol sizing)

existing size_multiplier() from v5.9.x risk_autotune

v5.10.2 will:

Add a small sizing adapter in symbol_score.py (if needed) to get factor + score in one go.

Patch signal_generator.size_for(...) to:

compute ATR/inverse-vol base size as before

compute symbol score & factor

return base_size * factor

Optional: expose size_factor in execution_health so dashboard can show it.

Tests to lock in behavior.

ðŸŸ¦ Commit 1 â€” Symbol Sizing Adapter Helper

Commit message:

[v5.10.2] Add helper to compute symbol size factor from symbol score


We already have score_to_size_factor(score) in execution/intel/symbol_score.py.
We add a helper that returns both:

1.1 Patch execution/intel/symbol_score.py

Add near the bottom:

def symbol_size_factor(symbol: str) -> dict:
    """
    Convenience wrapper that computes:
      - symbol score via compute_symbol_score
      - size factor via score_to_size_factor

    Returns:
        {
          "symbol": str,
          "score": float,
          "size_factor": float,
          "components": {...},  # same as compute_symbol_score
        }
    """
    payload = compute_symbol_score(symbol)
    score = payload.get("score") or 0.0
    factor = score_to_size_factor(score)
    return {
        "symbol": symbol,
        "score": score,
        "size_factor": factor,
        "components": payload.get("components") or {},
    }

1.2 Test: tests/test_symbol_score.py extension

Append:

from execution.intel.symbol_score import symbol_size_factor


def test_symbol_size_factor_wraps_score_and_factor_execution_intelligence(monkeypatch):
    def fake_compute_symbol_score(symbol):
        return {"symbol": symbol, "score": 2.0, "components": {}}

    monkeypatch.setattr(
        "execution.intel.symbol_score.compute_symbol_score",
        fake_compute_symbol_score,
    )

    sf = symbol_size_factor("BTCUSDC")
    assert sf["symbol"] == "BTCUSDC"
    assert sf["score"] == 2.0
    assert 1.0 < sf["size_factor"] <= 2.0  # high score -> >1x

ðŸŸ© Commit 2 â€” Integrate Size Factor into Signal Sizing

Commit message:

[v5.10.2] Apply symbol intelligence size factor on top of ATR/Sharpe sizing


Weâ€™ll adapt execution/signal_generator.py to use symbol_size_factor.

2.1 Patch execution/signal_generator.py

At top imports:

from execution.intel.symbol_score import symbol_size_factor


Find your existing size_for(symbol, gross_target) or equivalent.
The structure probably looks like:

compute raw base size from gross_target

apply inverse-vol sizing / ATR scaling

apply Sharpe-based size_multiplier(symbol) or something similar.

Weâ€™ll wrap the final size with the intel factor.

Example structure (skeleton):

# execution/signal_generator.py

def size_for(symbol: str, gross_target: float) -> float:
    """
    Compute final position size for a symbol, incorporating:
      - base desired exposure (gross_target)
      - inverse-volatility sizing
      - ATR regime scaling
      - Sharpe-based size multiplier (risk_autotune)
      - v5.10.2 symbol intelligence factor (symbol_size_factor)

    v5.10.2: we multiply the existing final size by an additional
    size_factor derived from symbol score, clamped in [0.25, 2.0].
    """
    # Existing logic (simplified schematic)
    base_size = gross_target

    # Inverse-volatility + ATR regime scaling:
    base_size = inverse_vol_size(symbol, base_size)
    base_size *= volatility_regime_scale(symbol)

    # Sharpe-aware multiplier (from risk_autotune.size_multiplier)
    base_size *= size_multiplier(symbol)

    # NEW: symbol intelligence size factor
    intel = symbol_size_factor(symbol)
    factor = intel["size_factor"]

    final_size = base_size * factor
    return final_size


In your real file, weâ€™ll apply this pattern to the actual size_for function, keeping all earlier logic intact and only adding the symbol_size_factor multiplication at the end.

ðŸŸ¥ Commit 3 â€” Expose Size Factor in Execution Health (Optional but Highly Recommended)

This lets you see in the dashboard what final factor was applied.

Commit message:

[v5.10.2] Include symbol intelligence size factor in execution health snapshot

3.1 Patch execution/utils/execution_health.py

Somewhere in compute_execution_health(symbol) where you assemble the sizing section, import and call the new helper:

# execution/utils/execution_health.py

from execution.intel.symbol_score import symbol_size_factor

def compute_execution_health(symbol: str | None = None) -> dict:
    # ... existing logic ...
    # inside per-symbol branch:
    intel = symbol_size_factor(symbol)
    size_factor = intel["size_factor"]

    sizing = {
        "sharpe_7d": sharpe,
        "size_multiplier": size_multiplier_value,  # existing
        "intel_size_factor": size_factor,          # NEW
        "final_size_factor": size_multiplier_value * size_factor,
    }
    # ... return structure unchanged except for these new fields ...


Then the dashboard (Execution Health Overview) can display intel_size_factor and final_size_factor tiles.

3.2 Test: extend tests/test_execution_health.py

Add a check that:

compute_execution_health(symbol)["sizing"] now contains the new keys.

monkeypatch symbol_size_factor for deterministic values.

ðŸŸ¨ Commit 4 â€” Tests for Adaptive Sizing Behavior

Commit message:

[v5.10.2] Add regression tests for adaptive symbol intelligence sizing


Create a new test file:

4.1 tests/test_execution_intel_sizing.py
# tests/test_execution_intel_sizing.py

from execution.signal_generator import size_for


def test_size_for_respects_symbol_size_factor_execution_intelligence(monkeypatch):
    # Make inverse-vol and regime scale neutral (1.0x)
    monkeypatch.setattr(
        "execution.signal_generator.inverse_vol_size",
        lambda symbol, base_size: base_size,
    )
    monkeypatch.setattr(
        "execution.signal_generator.volatility_regime_scale",
        lambda symbol: 1.0,
    )

    # Make Sharpe-based multiplier neutral (1.0x)
    monkeypatch.setattr(
        "execution.signal_generator.size_multiplier",
        lambda symbol: 1.0,
    )

    # Low quality symbol factor 0.5x
    monkeypatch.setattr(
        "execution.signal_generator.symbol_size_factor",
        lambda symbol: {"symbol": symbol, "score": -2.0, "size_factor": 0.5, "components": {}},
    )

    low = size_for("BTCUSDC", gross_target=100.0)
    assert low == 50.0

    # High quality symbol factor 1.5x
    monkeypatch.setattr(
        "execution.signal_generator.symbol_size_factor",
        lambda symbol: {"symbol": symbol, "score": 2.0, "size_factor": 1.5, "components": {}},
    )

    high = size_for("BTCUSDC", gross_target=100.0)
    assert high == 150.0
    assert high > low


def test_size_for_still_applies_existing_stack_execution_intelligence(monkeypatch):
    # Inverse-vol halves size, regime doubles it, net 1x
    monkeypatch.setattr(
        "execution.signal_generator.inverse_vol_size",
        lambda symbol, base_size: base_size * 0.5,
    )
    monkeypatch.setattr(
        "execution.signal_generator.volatility_regime_scale",
        lambda symbol: 2.0,
    )
    # Sharpe multiplier 1.2x
    monkeypatch.setattr(
        "execution.signal_generator.size_multiplier",
        lambda symbol: 1.2,
    )
    # Intel factor 0.8x
    monkeypatch.setattr(
        "execution.signal_generator.symbol_size_factor",
        lambda symbol: {"symbol": symbol, "score": 0.0, "size_factor": 0.8, "components": {}},
    )

    size = size_for("BTCUSDC", gross_target=100.0)
    # 100 * 0.5 * 2.0 * 1.2 * 0.8 = 96.0
    assert size == 96.0